---
{"dg-publish":true,"permalink":"/Code/3.ComputerNetwork/CN.0a.应用层/","title":"应用层","noteIcon":""}
---


# 应用层

网络应用程序仅运行在端系统上，不涉及[[ComputerNetwork.0.计算机网络#^internetCore\|网络核心]]

**应用程序体系结构** (application architecture)：
- 客户-服务器(C/S)
	- 服务器存储资源，客户端仅向服务器请求资源，
	- 服务器持续运行，具有固定的IP地址和周知的端口号
	- 可扩展性差
- 对等模式P2P(peer-to-peer)
	- 任意端系统都能相互通信
	- 自扩展性(self-scalability)
	- 管理困难
- 混合模式
	- 客户端登录时向服务器注册
	- 端系统相互通信

## 应用层通信原理

网络应用依赖于进程端口的相互通信，在同一个主机内使用进程间通信机制通信，在不同主机上通过交换报文来通信
- 进程：在主机上运行的应用程序
- 客户端进程：发起通信的进程
- 服务器进程：等待通信的进程
- P2P中也存在客户端进程和服务器进程

应用层通过IP地址和端口号确定传输双方的身份
每个主机具有唯一的一个32位的IP地址
每个进程具有一个**端口号**(port number)，流行的应用协议分配有特定的端口号
TCP、UDP 分别实现了端口，因此两个协议的端口不会互相影响。

**应用层协议**规定了不同端系统上的应用进程如何相互交换报文
- 交换的报文类型，例如请求报文和响应报文。
- 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。
- 字段的语义，即这些字段中的信息的含义。
- 确定一个进程何时以及如何发送报文，对报文进行响应的规则。

## 应用层相关协议

### HTTP协议


<div class="transclusion internal-embed is-loaded"><a class="markdown-embed-link" href="/code/3-computer-network/cn-0a1-http/#http" aria-label="Open link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><div class="markdown-embed">





# HTTP 协议

《图解 HTTP》阅读笔记
> [3.1 HTTP 常见面试题 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/network/2_http/http_interview.html#http-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)

## HTTP 基础知识

HTTP 协议**用于客户端和服务端之间的双向通信**，使用 *URI* 定位互联网上的资源，通过*请求报文*和*响应报文*建立通信

HTTP 协议基于 TCP 协议，默认应用端口为80
> [!attention]
> HTTP/3改用UDP协议

### HTTP报文

#### 报文内容

请求报文是由*请求方法*、*请求 URI*、*协议版本*、*可选的请求首部字段*和*内容实体*构成的，编码格式为ASCII

![|600](https://image.jiang849725768.asia/2022/202211202049360.png)

响应报文基本上由*协议版本*、*状态码*(表示请求成功或失败的数字代码)、*用以解释状态码的原因短语*、*可选的响应首部字段*以及*实体主体*构成

![|600](https://image.jiang849725768.asia/2022/202211202054456.png)

*请求报文*：
- 报文首部
	- 请求行 - 用于请求的方法，请求 URI 和 HTTP 版本
	- 请求首部字段 - 从客户端向服务器端发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息
	- 通用首部字段 - 请求报文和响应报文两方都会使用的首部
	- 实体首部字段 - 针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息
	- 其他 - 包含 HTTP 的 RFC 里未定义的其他首部(Cookie 等)
- 空行(CR+LF) - CR：回车符；LF：换行符
- 报文主体(**非必需**)

*响应报文*：
- 报文首部
	- 状态行 - HTTP 版本，表明响应结果的状态码和原因短语
	- 响应首部字段 - 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。
	- 通用首部字段
	- 实体首部字段
	- 其他
- 空行(CR+LF)
- 报文主体(**非必需**)

*报文(message)*：HTTP 通信中的基本单位，由**8位组字节流**(octet sequence，其中 octet 为 8 个比特)组成，通过 HTTP 通信传输。
*实体(entity)*：作为请求或响应的有效载荷数据(补充项)被传输，其内容由*实体首部*和*实体主体*组成。

**通常，报文主体等于实体主体**，传输中进行编码操作时实体主体的内容发生变化

##### 首部字段

HTTP 首部字段格式为 `{首部字段名}: {字段值}`
首部字段用于给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。
对单一报文中相同首部字段名重复出现的处理在规范内尚未明确，依赖于浏览器的内部处理逻辑
标准中没有对每个协议头字段的名称和值的大小设置任何限制，也没有限制字段的个数。然而，出于实际场景及安全性的考虑，**大部分的服务器、客户端和代理软件都会实施一些限制**

HTTP 首部字段根据是否缓存代理分成 2 种类型：
- *端到端首部*(End-to-end Header)
	- 此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。
- *逐跳首部*(Hop-by-hop Header)
	- 此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。*HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。*
	- HTTP/1.1中的逐跳首部字段：Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade

具体的首部字段内容及说明可查阅 [HTTP头字段-维基百科](https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%9E%E6%A0%87%E5%87%86%E5%9B%9E%E5%BA%94%E5%AD%97%E6%AE%B5)

- `Host` - 客户端发送时指定服务端的域名
- `Content-Length` - 服务端响应时告知数据长度
- `Content-Type`  - 服务器响应时告知数据格式
- `Content-Encoding` - 服务器响应时告知数据压缩方法
- `Connection` - 客户端要求服务器使用*HTTP 长连接*机制

请求报文首部示例：

```http
GET / HTTP/1.1
Host: hackr.jp
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0.8
Accept-Language: ja,en-us;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
```

响应报文首部示例：

```http
HTTP/1.1 200 OK
Date: Fri,13 Jul 2012 02:45:26 GMT
Server: Apache
Last-Modified: Fri,31 Aug 2007 02:02:20 GMT
BTag: "45bae1-16a-46d776ac"
Accept-Ranges: bytes
Content-Length: 362
Connection: close
Content-Type: text/html
Content-Encoding: gzip
```

##### HTTP请求方法

常见HTTP方法包括：

|  方法   |                     作用                     |   协议   |
|:-------:|:--------------------------------------------:|:--------:|
|   GET   |             从服务器获取指定资源             | 1.0、1.1 |
|  POST   | 根据请求负荷(报文 body)对指定的资源做出处理 | 1.0、1.1 |
|  HEAD   |               获取报文首部字段               | 1.0、1.1 |
|   PUT   |                   传输文件                   | 1.0、1.1 |
| DELETE  |                   删除文件                   | 1.0、1.1 |
| OPTIONS |                 询问支持方法                 |   1.1    |
|  TRACE  |                   追踪路径                   |   1.1    |
| CONNECT |            要求用隧道协议连接代理            |   1.1    |
|  PATCH  |              对资源应用部分修改              |   1.1    |

GET 方法是**安全且幂等**的，无论操作多少次，服务器上的数据都安全且每次的结果相同
所以浏览器可以对 GET 请求的数据做缓存，而且在浏览器中 GET 请求可以保存为书签
POST 是新增或提交数据的操作，会修改服务器上的资源，所以是**不安全且非幂等的**
所以浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签


<div class="transclusion internal-embed is-loaded"><div class="markdown-embed">



## 幂等
假如在不考虑诸如错误或者过期等问题的情况下，若干次请求的副作用与单次请求相同或者根本没有副作用，那么这些请求方法就能够被视作“**幂等**”的


</div></div>


GET，HEAD，PUT 和 DELETE 方法都有幂等属性，同样由于根据协议，OPTIONS，TRACE 都不应有副作用，因此也理所当然也是幂等的

> [!Notes]
>   GET 请求可以携带 body ，RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body

##### HTTP状态码

|     |              类别               |                               原因短语                                |
|:---:|:-------------------------------:|:---------------------------------------------------------------------:|
| 1XX |  Informational (信息性状态码)   |                          接收的请求正在处理                           |
| 2XX |      Success (成功状态码)       |                           请求正常处理完毕                            |
| 3XX |   Redirection (重定向状态码)    | 客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源 |
| 4XX | Client Error (客户端错误状态码) |                 客户端发送的报文有误，服务器无法处理                  |
| 5XX | Server Error (服务器错误状态码) |        客户端请求报文正确，但是服务器处理时内部发生了错误         |

**常见状态码**：
- *200 OK* 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据
- *204 No Content* 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据
- *206 Partial Content* 是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态

- *301 Moved Permanently* 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问
- *302 Found* 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问
- *304 Not Modified* 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制

- *400 Bad Request* 表示客户端请求的报文有错误，但只是个笼统的错误
- *403 Forbidden* 表示服务器禁止访问资源，并不是客户端的请求出错
- *404 Not Found* 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端

- *500 Internal Server Error* 与 400 类型相似，是个笼统通用的错误码
- *501 Not Implemented* 表示客户端请求的功能还不支持
- *502 Bad Gateway* 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误
- *503 Service Unavailable* 表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思

具体代码及含义可直接查阅[HTTP 状态代码概述 - Internet Information Services | Microsoft Learn](https://learn.microsoft.com/zh-cn/troubleshoot/developer/webapps/iis/www-administration-management/http-status-code)

### 数据传输

需传输的数据编码压缩后，分块传输，由客户端进行解码恢复
- 常见内容编码包括：
	- **gzip**(GNU zip)
	- **compress**(UNIX 系统的标准压缩)
	- **deflate**(zlib)
	- **identity**(不进行编码)
- 块使用十六进制标记大小，实体主体的最后一块会使用“0(CR+LF)”来标记

对于包含多种数据类型的实体，采用*多部分对象集合*并在首部字段中加入`Content-type`
- 多部分对象集合的每个部分类型中，都可以含有首部字段
- 可以在某个部分中嵌套使用多部分对象集合

对于断连后的重新传输，可以**通过范围请求指定下载的实体范围**，仅请求部分资源，请求报文首部字段包含`Range`

#### Cookies状态管理

**HTTP 协议为无状态协议**，不对之前发生过的请求和响应的状态进行管理，需使用*Cookies*记录状态

**客户端和服务端首次通信时**，服务器端通过响应报文内的`Set-Cookie`的首部字段信息通知客户端保存服务器发送的 Cookie，下次客户端向该服务器发送请求时自动在请求报文中加入 Cookie 值后发送
服务端检查 Cookie 获取状态信息

#### HTTP 缓存

> [HTTP 缓存-小林 coding](https://xiaolincoding.Com/network/2_http/http_interview.Html#http-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF)

可将一些具有重复性的 HTTP 请求及其响应缓存在本地以提升性能

##### 强制缓存

*强制缓存*指只要浏览器判断缓存没有过期，则直接使用本地缓存
强制缓存利用 HTTP 首部字段中的 `Cache-Control` (相对时间)和 `Expires` (绝对时间)字段实现，它们都用来表示资源在客户端缓存的有效期：
如果 HTTP 响应头部同时有 `Cache-Control` 和 `Expires` 字段的话，**`Cache-Control` 的优先级高于 `Expires`**

`Cache-control` 选项更多一些，设置更加精细，所以建议使用 `Cache-Control` 来实现强制缓存
具体的实现流程如下：
- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在响应报文头部加上 `Cache-Control` 设置过期时间大小
- 浏览器再次请求访问服务器中的该资源时，**先通过请求资源的时间与 `Cache-Control` 中设置的过期时间大小计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器
- 服务器再次收到请求后，通过响应报文再次更新`Cache-Control`

##### 协商缓存

*协商缓存*指客户端与服务端协商之后，通过协商结果来判断是否使用本地缓存
协商缓存的响应报文状态码为304，有两种实现方式
1. 通过请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
    - `Last-Modified`：标示这个响应资源的最后修改时间
    - `If-Modified-Since`：当资源过期时，浏览器发现响应头中有 `Last-Modified` 声明，则再次发起请求的时候使用 `If-Modified-Since` 告知服务器 `Last-Modified` 值，服务器将其与被请求资源的最后修改时间进行对比
        - 如果最后修改时间较新(大)，说明资源又被改过，则返回最新资源，HTTP 200 OK
        - 如果最后修改时间较旧(小)，说明资源无新修改，响应 HTTP 304 走缓存
2. 通过请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段实现
    - `Etag`：唯一标识响应资源
    - `If-None-Match`：当资源过期时，浏览器发现响应头里有 `Etag`，则再次发起请求时使用 `If-None-Match` 告知服务器 `Etag` 值，服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200

相较于 `Last-Modified`， `ETag` 有如下优势：
1. 可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题
2. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次
3. 有些服务器不能精确获取文件的最后修改时间

**协商缓存需要配合强制缓存中 `Cache-Control` 字段使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**

> ![http缓存.png (1348×1122) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png)

### 返回内容

服务器存在多个相同内容的页面时，通过内容协商机制返回合适内容
*内容协商机制*指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。
内容协商以响应资源的*语言、字符集、编码方式*等作为判断的基准。

机制类型：
- 服务器驱动协商(Server-driven Negotiation)
	- 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理
- 透明协商(Transparent Negotiation)
	- 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法
- 客户端驱动协商(Agent-driven Negotiation)
	- 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择

## HTTPS

针对 HTTP 存在的部分缺点进行改进形成的扩展协议，**HTTP+ 加密(SSL) + 认证 + 完整性保护=*HTTPS***(超文本传输安全协议)
HTTPS 通过 *SSL*(安全套接层)/*TLS*(安全层传输协议)加密 HTTP 的通信内容

> *TSL* 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL/TLS

![|525](https://image.jiang849725768.asia/2022/202211261654567.png)

### HTTP 的安全问题

- **窃听风险** - 通信使用明文(不加密)，内容可能会被窃听
- **冒充风险** - 不验证通信方的身份，因此有可能遭遇伪装
- **篡改风险** - 无法证明报文的完整性，所以有可能已遭篡改

按TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视

HTTP 协议中的请求和响应不会对通信方进行确认，导致问题：
- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器
- 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端
- 无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息，只想发给特定用户通信的权限
- 无法判定请求是来自何方、出自谁手。即使是无意义的请求也会照单全收
- 无法阻止海量请求下的 DoS 攻击(拒绝服务攻击)

请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为**中间人攻击**(MITM)
使用 HTTP 协议确定报文完整性常用的是 **哈希算法生成散列值**进行校验，以及用来确认文件的以 *PGP*创建的*数字签名*校验
HTTP 下用户需要亲自使用上述方法进行验证，同时无法意识到针对 PGP 和 MD5的篡改

### HTTPS 安全保证

SSL/TLS 协议可以很好地解决上述风险：
- **信息加密**：交互信息无法被窃取
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示
- **身份证书**：网站的身份可以得到证明

具体的操作方式：
- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险

#### 混合加密

- *非对称加密*又称*公开密钥加密*，使用一对非对称的密钥(*私有密钥*&*公开密钥*)进行加密，两个密钥可以双向加解密
  - 公钥加密，私钥解密：**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容
  - 私钥加密，公钥解密：**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的
*- 对称加密*也被叫做共享密钥加密，加密和解密同用一个密钥

- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

HTTPS 采用**共享密钥加密和公开密钥加密两者并用**的*混合加密*机制
- 建立通信时交换密钥环节使用公开密钥非对称加密
- 通信过程中交换报文阶段则使用共享密钥加密

#### 摘要算法&数字签名

应用层发送数据时会附加用摘要算法(哈希函数)生成的报文摘要
通过比对报文摘要能够查知报文是否遭到篡改，从而保护报文的完整性

但是摘要算法不保证报文内容和哈希值没有被中间人整体替换，可以通过**私钥加密报文摘要，公钥解密**的方法确认消息来源可信，这种方法又被称为*数字签名算法*

#### 身份证书

公开密钥的有效性通过由数字证书认证机构和其相关机关颁发的*公开密钥证书*来验证

*数字证书认证机构*(CA)为可信赖的第三方机构
1. 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打包，然后对这些信息进行 Hash 计算，得到一个 Hash 值
2. 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是数字签名
3. 最后将 Certificate Signature 添加在文件上，形成数字证书，然后分配该公开密钥
4. CA 使用自己的私钥对服务端申请的公开密钥做数字签名，将该公开密钥放入公钥证书后绑定在一起

**多数浏览器内部事先植入常用CA的公开密钥**
1. 客户端使用 CA 的公开密钥验证服务端数字证书上的签名
2. 验证成功后客户端从数字证书获取服务端公钥，加密报文后发送
3. 服务端使用私钥解密报文获取报文

> ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的
证书链的目的是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题
> ![证书链.png (1478×452) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E9%93%BE.png)

安全性极高的认证机构可颁发*客户端证书*但仅用于特殊用途的业务，如网银系统
客户端证书**只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性**

*EV SSL 证书*可确认对方服务器背后运营的企业是否真实存在
每个人都可以用开源程序OpenSSL构建属于自己的认证机构，从而自己给自己颁发服务器证书，由自认证机构颁发的证书称为**自签名证书**

### TLS 握手流程

基本流程：
1. 客户端向服务器索要并验证服务器的公钥
2. 双方协商生产会话秘钥
3. 双方采用会话秘钥进行加密通信

![](https://image.jiang849725768.asia/2022/202211261754805.png)
- CBC 模式(Cipher Block Chaining)又名密码分组链接模式

#### TLS1.2

TLS1.2 的握手阶段涉及四次通信，使用不同的密钥交换算法的流程不同，现在常用的密钥交换算法有两种：*RSA 算法* 和 *ECDHE 算法*

##### RSA

RSA 算法握手具体流程：
1. 第一次握手
    1. 客户端向服务器发起加密通信 ` Client Hello ` 请求
        - 客户端支持的 TLS 协议版本
        - 客户端生产的随机数 `Client Random`
        - 客户端支持的密码套件列表，如 RSA 加密算法
2. 第二次握手
    1. 服务器向客户端发出 `Sever Hello` 响应请求
        - 确认支持 TLS 协议的版本(不支持时关闭加密通信)
        - 服务器生产的随机数 `Server Random`
        - 确认的密码套件，如 RSA 加密算法
    2. 服务器向客户端发出 `Server Certificate` 响应请求
        - 服务器的数字证书
    3. 服务器向客户端发出 `Server Hello Done` 响应请求
        - 告知客户端内容发送完毕
3. 客户端通过 CA 公钥验证数字证书，取出服务器公钥，生成一个随机数 `pre-master`，进而通过协商的加密算法生成会话密钥
4. 第三次握手
    1. 客户端向服务器发送 `Cilent Key Exchange` 报文
        - 以服务器公钥加密的随机数 `pre-master`
    2. 客户端向服务器发送 `Change Cipher Spec` 报文
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    3. 客户端向服务器发送 `Encrypted Handshake Message（Finishd)` 报文
        - 客户端握手结束通知，表示客户端的握手阶段已经结束，同时将之前所有内容生成摘要，用会话密钥加密供服务端校验
5. 服务器通过协商的加密算法计算出本次通信的会话秘钥
6. 第四次握手
    1. 服务器向客户端发送 `Change Cipher Spec` 报文
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    2. 服务器向客户端发送 `Encrypted Handshake Message` 报文
        - 服务器握手结束通知，表示服务器的握手阶段已经结束，同时将之前所有内容生成加密摘要供客户端校验

服务器和客户端**用双方协商的加密算法对过程中交换的三个随机数 `Client Random`、`Server Random`、`pre-master key` 进行加密**，各自生成相同的*会话秘钥(共享密钥)* 用于本次通信的对称加密

基于 RSA 算法的 HTTPS 存在**前向安全问题**：**如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解**

##### ECDHE

> [!TODO]
> 完成ECDHE 握手相关内容

> [!Note] DH
> ![离散对数.png (692×227) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png)
> 通过离散对数，确认 a 与 p 值后，以 i 为私钥可以计算出公钥 b，目前的计算机能力无法做到由 b 反推 i
> 客户端与服务端交流确认相同的 a 与 p 值，各自生成私钥 $i_c$、$i_s$，进而计算出各自公钥 $b_c$、$b_s$，交换公钥后可以计算出相同的结果 K
> $ K={b_s}^{i_c}(mod\ p)=(a^{i_s})^{i_c}(mod\ p)=(a^{i_c})^{i_s}(mod\ p)= {b_c}^{i_s}(mod\ p)$
> K 即为客户端与服务端之间的**对称加密密钥**，可以作为会话密钥使用

**为实现前向安全，每次通信随机生成私钥**，但计算量大，性能不佳
*ECDHE 算法*通过 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥
1. 双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数公开不加密
2. 双方各自随机生成一个随机数作为私钥 d，并与基点 G 相乘得到公钥 `Q = dG`，此时客户端的公私钥为 Q1 和 d1，服务器的公私钥为 Q2 和 d2
3. 双方交换各自的公钥，最后客户端计算点 `(x1，y1) = d1Q2`，服务器计算点 `(x2，y2) = d2Q1`，由于椭圆曲线满足乘法交换和结合律，所以 `d1Q2 = d1d2G = d2d1G = d2Q1` ，因此双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥

ECDHE 算法握手具体流程：
1. 第一次握手
    1. 客户端向服务器发起加密通信 ` Client Hello ` 请求
        - 客户端支持的 TLS 协议版本
        - 客户端生产的随机数 `Client Random`
        - 客户端支持的密码套件列表
2. 第二次握手
    1. 服务器向客户端发出 `Sever Hello` 响应请求
        - 确认支持 TLS 协议的版本(不支持时关闭加密通信)
        - 服务器生产的随机数 `Server Random`
        - 确认的密码套件
    2. 服务器向客户端发出 `Server Certificate` 响应请求
        - 服务器的数字证书
    3. **服务器生成随机数作为服务端椭圆曲线的私钥，向客户端发出 `Server Key Exchange` 响应请求**
        - 选择的椭圆曲线类型(同时确定了基点G)
        - 根据基点 G 和私钥计算出的服务端的椭圆曲线公钥(用 RSA 签名算法进行数字签名)
    4. 服务器向客户端发出 `Server Hello Done` 响应请求
        - 告知客户端内容发送完毕
3. 客户端通过 CA 公钥验证服务器身份，**生成一个随机数作为客户端椭圆曲线的私钥，进而生成客户端的椭圆曲线公钥**，同时通过协商的加密算法生成会话密钥
4. 第三次握手
    1. 客户端向服务器发送 `Cilent Key Exchange` 报文
        - 客户端椭圆曲线公钥
    2. 客户端向服务器发送 `Change Cipher Spec` 报文
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    3. 客户端向服务器发送 `Encrypted Handshake Message（Finishd)` 报文
        - 客户端握手结束通知，表示客户端的握手阶段已经结束，同时将之前所有内容生成摘要，用会话密钥加密供服务端校验
5. 服务器通过协商的加密算法计算出本次通信的会话秘钥
6. 第四次握手
    1. 服务器向客户端发送 `Change Cipher Spec` 报文
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    2. 服务器向客户端发送 `Encrypted Handshake Message` 报文
        - 服务器握手结束通知，表示服务器的握手阶段已经结束，同时将之前所有内容生成加密摘要供客户端校验

#### TLS1.3

TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，只需 1 RTT 就能完成 TLS 握手

> ![tls1.2and1.3.png (1832×1290) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls1.2and1.3.png)

具体做法：
1. 客户端在第一次握手时的 `Client Hello` 消息里带上了支持的椭圆曲线以及这些椭圆曲线对应的公钥
2. 服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端生成的公钥
3. 二者生成会话密钥进行加密通信

此外 TLS1.3 对于密钥交换算法废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法

#### TLS 优化

##### 会话复用

*Session ID*
客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识
当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信
为了安全性，内存中的会话密钥会定期失效
缺点：
- 服务器必须保持每一个客户端的会话密钥，随着客户端的增多，**服务器的内存压力也会越大**
- 现在网站服务一般是由多台服务器通过负载均衡提供服务的，**客户端再次连接不一定会命中上次访问过的服务器**，于是还要走完整的 TLS 握手过程

*Session Ticket*
服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端
客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket
客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信

对于集群服务器的话，要确保每台服务器加密会话密钥的密钥是一致的，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话

Session ID 和 Session Ticket 都**不具备前向安全性**，一旦加密会话密钥的密钥被破解或者服务器泄漏会话密钥，前面劫持的通信密文都会被破解

同时应对*重放攻击*也很困难

*Pre-shared Key*

重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端

Pre-shared Key 也有重放攻击的危险

> [!Note] 重放攻击
> ![重放攻击](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB.png)
> 假设 Alice 想向 Bob 证明自己的身份。 Bob 要求 Alice 的密码作为身份证明，爱丽丝应尽全力提供（可能是在经过如哈希函数的转换之后）。与此同时，Eve 窃听了对话并保留了密码（或哈希）
> 交换结束后，Eve（冒充 Alice ）连接到 Bob。当被要求提供身份证明时，Eve 发送从 Bob 接受的最后一个会话中读取的 Alice 的密码（或哈希），从而授予 Eve 访问权限
> 重放攻击的危险之处在于，如果中间人截获了某个客户端的 Session ID 或 Session Ticket 以及 POST 报文，而一般 POST 请求会改变数据库的数据，中间人就可以利用此截获的报文，不断向服务器发送该报文，这样就会导致数据库的数据被中间人改变了，而客户是不知情的
>避免重放攻击的方式就是需要**对会话密钥设定一个合理的过期时间**

### 应用数据完整性

TLS 在实现上分为*握手协议*和*记录协议*两层：
- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据
- TLS 记录协议负责**保护应用程序数据并验证其完整性和来源**，所以对 HTTP 数据加密是使用记录协议

具体流程：
1. 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩
2. 接下来，经过压缩的片段会被加上消息认证码(哈希值)以保证完整性并进行数据的认证，通过附加消息认证码的 MAC 值，可以识别出篡改，与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码
3. 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密
4. 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据

### HTTPS存在的问题

- 由于需要加密以及解密，HTTPS 的速度往往慢于 HTTP
- 进行SSL通信导致通信量的增加
- 服务端和客户端进行的加密解密消耗了时间，加大了主机的负担

## HTTP 发展

### HTTP/1.1

#### 优点

HTTP 最突出的优点是**简单、灵活和易于扩展、应用广泛和跨平台**

- 简单
  HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。
- 灵活和易于扩展
  HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**
  同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**，比如：
  - HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层
  - HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议
- 应用广泛，跨平台
  互联网发展至今，HTTP 的应用范围非常的广泛，同时天然具有**跨平台**的优越性

HTTP/1.1 VS HTTP/1.0 ：
- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道化网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间

#### 缺点

- 无状态
- 明文传输
- 不安全

#### 性能

HTTP/1.1 和部分 HTTP/1.0使用*持久连接(长连接)*，客户端和服务端任意一端提出断开前保持 TCP 连接，HTTP/1.1中所有链接默认为持久连接

HTTP/1.1中可使请求以*管线化*(pipelining)方式发送，实现同时并行发送多个请求，新请求的发送不需要等待上一个请求对应响应的接收
**管线化解决了请求的队头阻塞，但是没有解决响应的队头阻塞**，服务器必须按照接收请求的顺序发送对这些管道化请求的响应
**实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持**

性能瓶颈：
- 一条连接上只可发送一个请求
- 请求 / 响应首部未经压缩就发送，首部信息越多延迟越大，只能压缩 Body 的部分
- 每次互相发送相同的首部造成的浪费较多
- 没有请求优先级控制
- 请求只能从客户端开始，服务器只能被动响应
- 管线化未充分解决阻塞问题
	- 只有幂等的请求比如 GET、HEAD 才能使用 pipelining ，非幂等请求比如 POST 则不能使用，因为请求之间可能存在先后依赖关系
	- 队头阻塞问题并没有完全解决，因为服务器返回的响应还是要依请求顺序先发先回
	- 绝大多数 HTTP 代理服务器不支持 pipelining
	- 浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞

### HTTP/2

> [!Cite]  参考
> [HTTP/2 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/HTTP/2)
> [再过五分钟，你就懂 HTTP 2.0 了！_程序员cxuan的博客-CSDN博客](https://cxuan.blog.csdn.net/article/details/120037166)
> [HTTP/2 相比 1.0 有哪些重大改进？ - leozhang2018的回答 - 知乎](https://www.zhihu.com/question/34074946/answer/75364178)
> [Http系列(二) Http2中的多路复用 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903935648497678)

*HTTP/2*(超文本传输协议第2版，最初命名为*HTTP 2.0*)，简称为*h2*(基于 TLS/1.2或以上版本的加密连接)或*h2c*(非加密连接)

HTTP/2的设计本身允许非加密的 HTTP 协议，也允许使用 TLS 1.2或更新版本协议进行加密
协议本身未要求必须使用加密，但多数客户端只会实现通过 TLS 加密的 HTTP/2协议，使得**经 TLS 加密的 HTTP/2成为了事实上的强制标准**，而 h2c 事实上被主流浏览器废弃

#### 起源: SPDY

HTTP 的瓶颈：**带宽**和**延迟**

Google 在 2010 年发布了 **SPDY**(取自 SPeeDY，发音同 speedy)，SPDY 的目标在于解决 HTTP 的缺陷，即延迟和安全性
SPDY 在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL

*SPDY 功能*：
- 多路复用流 - 通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。
- 服务器主动推送数据
- 压缩 HTTP 首部
- 赋予请求优先级
- 服务器提示 - 服务器可以主动提示客户端请求所需的资源。

#### HTTP/2 优化

**基于普适性的重要前提**：
- 客户端向服务器发送请求的这种基本模型不会改变
- 原有的协议头不会改变，使用 http:// 和 https:// 的服务和应用不会做任何修改，不会有 http2://
- 使用 HTTP 1.X 的客户端和服务器可以平滑升级到 HTTP 2.0 上
- 不识别 HTTP 2.0 的代理服务器可以将请求降级到 HTTP 1.X

因此 HTTP/2创建了一个协商协议标准，即*应用层协议协商*(ALPN)，以便客户端能够从 HTTP/1.0、HTTP/1.1、HTTP/2乃至其他非 HTTP 协议中做出选择
ALPN 是一个 TLS 的扩展

**重要特点**：
- **二进制分帧**
  在应用层(HTTP/2)和传输层(TCP/UDP)之间增加一个二进制分帧层，HTTP/2在层中将所有传输的信息采用二进制格式的编码分割为更小的消息和帧(frame)，其中首部信息封装到 HEADERS frame，内容实体则封装到 DATA frame
	![](https://image.jiang849725768.asia/2022/202211272107027.png)
- **多路复用**
  HTTP/2所有请求都是通过一个 TCP 连接并发完成，**将一个 TCP 连接分为若干 stream**，每个 stream 传输若干 message，每个 message 由若干二进制 frame 组成
  接收方根据不同 frame 首部唯一的 stream id 标识符区分不同的 HTTP 请求，重新将报文连接组装
  HTTP/2可以对不同的 stream 设置不同的优先级，stream 之间也可以设置依赖，依赖和优先级都可以动态调整，**解决关键请求被阻塞的问题**
- **首部压缩**
  HTTP/2使用 *HPACK 压缩算法*来减少传输的 header 大小，同时通信双方各自缓存一份 header 字段表，避免重复传输 header ，减少传输内容
- **服务端推送**
  服务端可以主动向客户端发送消息，客户端和服务器**双方都可以建立 Stream**，**客户端建立的 stream id 必须是奇数，而服务器建立的 stream id 必须是偶数**
  客户端请求 html 文件时服务器可直接提供渲染页面所需 css 文件，无须客户端收到、解析页面后再提起一轮请求，节约了加载时间
  当服务端需要主动推送某个资源时会发送一个 Frame Type 为 `PUSH_PROMISE` 的 frame ，里面带了 PUSH 需要新建的 stream id

> [!Note]  帧&流
> **帧**(Frame)：
> - HTTP/2 中**数据传输的最小单位**，
> - 每一帧都包含几个字段，有*length、type、flags、stream identifier、frame playload*等，其中 type 代表帧的类型，在 HTTP/2 的标准中定义了 10 种不同的[类型](https://webconcepts.info/concepts/http2-frame-type/)
> - 传输时 **HEADERS 帧在 DATA 帧前面**
>
> **流**(Stream)：
> - 存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数**Stream ID**
> - **双向性**：同一个流内，可同时发送和接受数据
> - **有序性**：流中被传输的数据就是二进制帧。帧在流上的被发送与被接收都是按照顺序进行的
> - **并行性**：流中的二进制帧都是被并行传输的，无需按顺序等待
> - 流的创建：流可以被客户端或服务器单方面建立, 使用或共享
> - 流的关闭：流也可以被任意一方关闭
> - 为了防止两端 stream id 冲突，客户端发起的流具有奇数 id，服务器端发起的流具有偶数 id

#### HTTP/2 缺点

- 应用层协议协商导致的一次额外来回通信延迟(RTT)
- HTTP/2 基于 TCP 协议传输数据，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，出现丢包时，之后到达的所有数据只能存放在内核缓冲区里，该 TCP 连接内的所有 Stream 都被阻塞，等到该丢包数据到达时才能被 HTTP 读取

### HTTP/3

> [!Cite]  参考
> [HTTP/3 - 維基百科，自由的百科全書 (wikipedia.org)](https://zh.wikipedia.org/zh-hk/HTTP/3)
> [5分钟看懂HTTP3_文化 & 方法_Mehdi Zed_InfoQ精选文章](https://www.infoq.cn/article/whcobxfbgtphy7ijv1kp)

**HTTP/3**是第三个主要版本的 HTTP 协议。HTTP/3中弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议实现

> ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png)

#### HTTP/3优化

- **无队头阻塞**
  QUIC 同样采取多路复用和 Stream，以自身机制保证传输的可靠性，当某个 stream 发生丢包时，仅阻塞这个 stream，其他 stream 不会受到影响，因此不存在队头阻塞问题
- **更快的连接建立**
>![28-HTTP3交互次数.png (742×492) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png)
   ![|525](https://cdn.xiaolincoding.com//mysql/other/4cad213f5125432693e0e2a512c2d1a1-20230309231022316.png)

  QUIC 内部包含 TLS，仅需 1 个 RTT 就可以同时完成建立连接与密钥协商
  更进一步，在第二次连接的时候，应用数据包可以和 QUIC 握手信息(连接信息 + TLS 信息)一起发送，达到 0-RTT 的效果
- **连接迁移**
  基于 TCP 的 HTTP 在 IP 地址变化时需要重新建立 TCP 连接
  QUIC 协议**通过*连接 ID* 来标记通信的两个端点**，端点 IP 变化时可通过上下文信息(连接 ID、TLS 密钥等)复用原连接，实现连接迁移，消除重连成本

#### HTTP/3缺点

- QUIC 协议包对于旧设备会被当作 UDP 丢包
- 普及慢

## 用户身份认证

常见认证信息：密码、动态令牌、数字证书、生物认证、IC卡等

HTTP/1.1使用的认证方式：BASIC 认证(基本认证)、DIGEST 认证(摘要认证)、SSL 客户端认证、FormBase 认证(基于表单认证)等

### Basic 认证

![](https://image.jiang849725768.asia/2022/202211271047364.png)

- 安全性低，明文解码后就是用户 ID和密码
- 一般浏览器无法实现认证的注销操作

### DIGEST认证

![](https://image.jiang849725768.asia/2022/202211271054320.png)

1. ①中首部字段 `WWW-Authenticate` 内必须包含 `realm` 和 `nonce` 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。
2. ②中首部字段 `Authorization` 内必须包含 `username`、`realm`、`nonce`、`uri` 和 `response` 的字段信息。
	- `realm` 和 `nonce` 就是之前从服务器接收到的响应中的字段。
	- `username` 是 `realm` 限定范围内可进行认证的用户名
	- `uri`(digest-uri)即 `Request-URI` 的值，经代理转发后`Request-URI`的值可能被修改，因此事先会复制一份副本保存在`uri`内。
	- `response` 也可叫做 `Request-Digest`，存放经过 MD5 运算后的密码字符串，形成响应码。

### SSL客户端认证

借由 HTTPS 的客户端证书完成认证

步骤：
1. 接收到需要认证资源的请求，服务器会发送 `CertificateRequest` 报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 `Client Certificate` 报文方式发送给服务器。
3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。

多数情况下和[[Code/3.ComputerNetwork/CN.0a1.HTTP协议#表单认证\|表单认证]]组合形成一种**双因素认证**(Two-factor authentication)来使用

### 表单认证

基于表单的认证方法不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息(Credential)，按登录信息的验证结果认证。

***用户身份认证多半基于表单认证***
基于表单认证的标准规范尚未有定论，一般会使用 **Cookie** 来管理 **Session**(会话)。

1. 客户端使用HTTPS进行用户输入数据(用户名&密码)的发送
2. 服务器将用户认证状态和**Session ID**绑定后向用户发放包含Session ID的cookies
3. 之后客户端发送请求时服务器验证接收到的Cookies中的Session ID识别用户和其认证状态

服务器端应如何保存用户提交的密码等登录信息等也没有标准化，通常的安全做法是先利用给密码加盐(salt)的方式增加额外信息，再使用散列(hash)函数计算出散列值后保存。
- salt 是由服务器随机生成的一个长度足够长的字符串，和密码字符串相连接(前后都可以)生成散列值。
- 当两个用户使用了同一个密码时，由于随机生成的 salt 值不同，对应的散列值也将是不同的。

## Web 服务器

### 虚拟主机

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点，因此**利用虚拟主机可令一个IP地址配对多个URI**
互联网通过DNS服务将URI解析为IP进行连接，连接至服务器上通过首部中的`Host`指定的URI确认具体的访问域名

### 转发服务器

#### 代理/缓存

**代理服务器**(proxy server)也叫**Web缓存器**(Web cache)，其接收客户端发送的请求后转发给其他服务器。代理*不改变请求 URI*，会直接发送给前方持有资源的目标服务器。
每次通过代理服务器转发请求或响应时，会追加写入`Via`首部信息

*用途*：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等等

*类型*：**缓存/非缓存代理**、**透明/非透明代理**
代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上
转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理

**缓存服务器**是代理服务器的一种，并归类在缓存代理类型中，缓存可以存在于缓存服务器内或客户端浏览器中。判定缓存过期后，会向源服务器确认资源的有效性，若判断浏览器缓存失效，浏览器会再次请求新资源。***缓存服务器既是服务器又是客户端。*** 当它接收浏览器的请求并发回响应时是服务器。当它向初始服务器发出请求并接收响应时是客户端。

- 降低客户端响应时间
- 减轻服务器负载

对于缓存的版本问题，HTTP使用**条件GET**(conditional GET)方法，在GET方法的首部字段中加入`If-Modified-Since`字段以确认缓存文件是否改变

#### 网关

转发其他服务器通信数据的服务器

*用途*：可以由 HTTP 请求转化为其他协议通信

#### 隧道

在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序

*用途*：用 SSL 等加密手段进行通信，确保客户端能与服务器进行安全的通信

## 相关知识

### 相关协议

*HTTP*(超文本传输协议(严谨译名应为*超文本转移协议*))是Web文档传递的规范，*WWW*(万维网)的三项构建技术之一，另两个是把 SGML(标准通用标记语言)作为页面的文本标记语言的 **HTML**(超文本标记语言)以及指定文档所在地址的 **URL**(统一资源定位符)

**DNS 协议**提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务

HTTP位于TCP/IP分层中的**应用层**，数据传输过程如下：
![|600](https://image.jiang849725768.asia/2022/202211261751316.png)

这种把数据信息包装起来的做法称为**封装**(encapsulate)

HTTP与各种协议的关系如下：
![|500](https://image.jiang849725768.asia/2022/202211212023993.png)

**URI**(Uniform Resource Identifier，统一资源定位标识符) 用字符串标识某一互联网资源，而 URL 表示资源的地点(互联网上所处的位置)，后者是前者的子集
表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL

`http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1`为**绝对URI**，不区分大小写
- `http`或`https`为协议方案名
- `user:pass`为登录信息(可选项)
	指定用户名和密码作为从服务器端获取资源时必要的登录信息
- `www.example.jp`为服务器地址
	类似这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是\[0:0:0:0:0:0:0:1\] 这样用方括号括起来的 IPv6 地址名
- `80`为服务器端口号(可选项)
	省略则自动使用默认端口号
- `/dir/index.htm`为带层次的文件路径
	指定服务器上的文件路径来定位特指的资源
- `uid=1`为查询字符串(可选项)
- `ch1`为片段标识符(可选项)

相对URL与带层次的文件路径类似

用来制定HTTP协议技术标准的文档被称为**RFC**(征求修正意见书)

### Web构建

Web页由HTML文件，JPEG图像等多种对象组成，其含有一个基本的HTML文件，该文件中包含对其他对象的引用(链接)

#### HTML

**HTML**(HyperText Markup Language，超文本标记语言)是为了发送Web 上的**超文本**(Hypertext)而开发的标记语言。
超文本是一种文档系统，可将文档中任意位置的信息与其他信息(文本或图片等)建立关联，即超链接文本。
标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。
我们把出现在 HTML 文档内的这种特殊字符串叫做 **HTML 标签**(Tag)

示例;
```html
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>hackr.jp</title>
<style type="text/css">
.logo {
padding: 20px;
text-align: center;
}
</style>
</head>
<body>
<div class="logo">
<p><img src="photo.jpg" alt="photo" width="240" height="127" /></p>
<p><img src="hackr.gif" alt="hackr.jp" width="240" height="84" /></p>
<p><a href="http://hackr.jp/">hackr.jp</a> </p>
</div>
</body>
</html>
```

HTML5是HTML最新的修订版本，广义论及HTML5时，实际指的是包括HTML、CSS和JavaScript在内的一套技术组合。

##### 动态HTML

**动态 HTML**(Dynamic HTML)是通过调用客户端脚本语言**JavaScript**将静态的 HTML 内容变成动态的技术的总称
利用 **DOM**(Document ObjectModel，文档对象模型)可指定欲发生动态变化的 HTML 元素

#### XML

**XML**(eXtensible Markup Language，可扩展标记语言)是一种可按应用目标进行扩展的通用标记语言。
XML 和 HTML 都是从标准通用标记语言 **SGML**(Standard GeneralizedMarkup Language)简化而成。与 HTML 相比，它对数据的记录方式做了特殊处理。

#### JSON

**JSON**(JavaScript Object Notation)是一种以JavaScript(ECMAScript)的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 *布尔值/空值/对象/数组/数字/字符串*，这7种类型。

#### CSS

**CSS**(Cascading Style Sheets，层叠样式表)可用于指定HTML和XML内的各种元素的样式。
示例：
```css
.logo {
padding: 20px;
text-align: center;
}
```

#### WEB应用

由程序创建的HTML内容称为*动态内容*，而事先准备好的HTML内容称为*静态内容*

**CGI**(Common Gateway Interface，通用网关接口)是为提供网络服务而执行控制台应用 (或称命令行界面)的程序。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建动态内容。

**Servlet** 是一种能在服务器上创建动态内容的程序，解决了CGI创建程序带来的服务器负担
Servlet 是用 Java语言实现的一个接口，属于面向企业级 Java的一部分


</div></div>


同时HTTP通过代理服务器减轻网络负载
[[Code/3.ComputerNetwork/CN.0a1.HTTP协议#代理/缓存\|CN.0a1.HTTP协议#代理/缓存]]

### FTP

**文件传输协议**(File Transfer Protocol，FTP)是一个用于在计算机网络上在客户端和服务器之间进行文件传输的应用层协议。默认控制端口号为21，传输端口号为20

FTP用于向远程主机上传输文件或从远程主机接收文件，使用客户-服务器结构

与HTTP相比，FTP维护用户状态，同时控制与数据传输采用不同的连接，通过控制连接发送命令及响应，使用数据传输连接来传输文件
在控制连接上以*ASCII文本*方式传送命令及响应

目前为止(2022-12-06)，FTP协议在主流浏览器中基本被弃用

### EMail

互联网电子邮件系统由**用户代理**(user agent)、**邮件服务器**(mail server) 和**简单邮件传输协议**(Simple Mail Transfer Protocol, **SMTP**)三部分组成
SMTP使用客户-服务器结构，默认端口为25，报文必须为7位ASCII码

用户代理为Outlook、Gmail等邮件处理应用
每个用户在邮件服务器上有一个邮箱，邮箱管理和维护发送给该用户的邮件

邮件：发送方用户代理->发送方服务器->报文队列->SMTP握手->基于SMTP发送email报文->接收方服务器->接收方邮箱->POP3/IMAP/HTTP->接收方用户代理

**POP**：邮局访问协议(Post Office Protocol)
- 无状态
- 用户将邮件下载至本地管理
**IMAP**：Internet邮件访问协议(Internet Mail Access Protocol)
- 会话过程中保留用户状态
- 将报文与文件夹关联，用户远程管理文件夹

发送失败：发送方用户代理->发送方服务器->报文队列->发送失败->间隔一段时间再次发送->多次失败->服务器删除报文并以email通知发送方

SMTP与HTTP的区别：
- HTTP为拉协议(pull protocol)，客户端向服务器请求拉取文件，SMTP为推协议(push protocol)
- HTTP报文不受ASCII码限制
- HTTP把每个对象封装到对象自身的HTTP响应报文中，SMTP则把所有报文对象放在一个报文之中

邮件报文格式：
![|525](https://image.jiang849725768.asia/2022/202212072023591.png)

**多媒体邮件扩展MIME**(multimedia mail extension)用于报文扩展，使用指定编码方式将非ASCII码内容编码为ASCII码发送

### DNS

**域名系统DNS**(Domain Name System)提供域名到IP地址的转换

DNS是：
- 一个由分层的DNS服务器(DNS server) 实现的分布式数据库
- 一个主机用于查询分布式数据库的应用层协议。
DNS协议运行在UDP之上，使用客户-服务器结构，默认端口为53

DNS功能：
- 主机名-IP地址的转换
- 主机别名( host aliasing) - 规范主机名(canonical hostname) 的转换
	- 有着复杂主机名的主机拥有一个或者多个别名
- 邮件服务器别名-规范主机名的转换
- 负载分配( load distribution)
	- 繁忙站点被冗余分布在多台服务器上，其规范主机名连接着一个IP地址集合

>[!note] 域名
>主机域名往往采用层次树状结构的命名方法，域名命名从本域往上，直到树根，中间使用“.”间隔不同的级别
>例如：`ustc.edu.cn`、`auto.ustc.edu.cn`、`www.auto.ustc.edu.cn`
>Internet 根被划为几百个顶级域(top lever domains)，每个(子)域下面可划分为若干子域(subdomains)，每个域管理自己的子域
>域的域名：可以用于表示一个域
>主机的域名：一个域上的一个主机

DNS服务器类型：
- 根DNS服务器
	- 提供TLD服务器的IP地址
- 顶级域(Top-Level Domain, TLD) DNS服务器
	- 负责顶级域名(如com, org, net,edu和gov)和所有国家级的顶级域名(如cn, uk, fr, ca,jp )
	- 提供权威DNS服务器的IP地址
- 权威DNS服务器
	- 组织机构的DNS服务器， 提供组织机构服务器(如Web和mail)可访问的主机和IP之间的映射
- 本地DNS服务器(Local DNS Server)
	- 严格来说不属于DNS系统的层次结构
	- 每个ISP都有一台本地DNS服务器

DNS工作过程：
- 递归查询![|375](https://image.jiang849725768.asia/2022/202212081811082.png)
	- 根节点负担重
- 迭代查询![|325](https://image.jiang849725768.asia/2022/202212081814132.png)
	- 根(及各级域名)服务器返回的不是查询结果，而是下一个NS的地址
	- 通过缓存可减少对根节点的请求

>[!note] DNS缓存
>在一个请求链中，当某DNS服务器接收到一个DNS回答(例如某主机名到IP地址的映射)时将映射缓存在本地存储器中，并在一定时间后丢弃。

DNS服务器将主机名到IP地址的映射关系以**资源记录**(Resource Record，RR)的形式进行存储
每条记录都包含`(Domain_Name, TTL, Type, Class, Value)`
- Domain_name: 域名
- TTL: time to live, 生存时间
- Class 类别：对于Internet，值为IN(可维护非Internet值)
- Value 值：可以是数字，域名或ASCII串
- Type 类别：资源记录的类型
	- A - Name=主机，Value=IP地址
	- CNAME - Name=别名，Value=规范主机名
	- NS - Name=域名，Value=该域名所属的权威服务器的域名
	- MX -Name=邮件服务器别名，Value=规范主机名

DNS协议：查询和响应报文的报文格式相同
报文首部包含12个字节，又分为六个字段，第一个字段为报文标识符(id)，第二个字段为标志，包含对报文类型的各种标志，如1bit的“查询/回答”标志位指出报文是查询报文(0)还是回答报文(1)

## P2P

纯P2P架构：
- 基本没有一直运行的服务器
- 任意端系统可以直接通信
- peer节点每次连接的IP地址可能变化

非结构化P2P：节点间随机连接
- 集中式目录，中心服务器管理资源关系
- 完全分布式：泛洪式查询，e.g. Gnutella
- 混合式：对等方连接组长，组长相互连接并管理资源关系，e.g. KaZaA
DHT(Distributed Hash Table)P2P(结构化)：节点间有序连接

通常使用Hash值作为文件的唯一标识

### BitTorrent

BitTorrent是一种用于文件分发的流行P2P协议

参与一个特定文件分发的所有对等方(peer)的集合被称为一个**洪流**(torrent) ，每个洪流具有一个基础设施节点**追踪器**(tracker) ，在一个洪流中的对等方彼此下载等长度的文件块(chunk)(通常大小为256KB)，一个对等方拥有块的情况由BitMap描述

当一个对等方X加入某洪流时
1. 它向追踪器注册自己并周期性地通知追踪器它仍在该洪流中
2. 追踪器随机地从参与对等方的集合中选择一个子集并将其中对等方的IP地址列表发送给X
3. X尝试与列表中的所有对等方建立并行的TCP连接，成功建立连接的对等方称为**邻近对等方**
4. X周期性询问每个邻近对等方所具有的块列表，并对其当前没有的块发出请求
5. 随时间流逝对等方可能会上线或者下线，邻近对等方会发生变化

请求块算法：**最稀缺优先**(rarest first)
针对当前没有的块在邻近对等方集合中的副本数量决定最稀缺的块，并首先请求那些最稀缺的块
发送块算法：**一报还一报**(tit-for-tat)
对每个邻近对等方实时监测块接收速率，向接收块速率最快的 4 个对等方优先发送块，同时每过 30 秒随机选择一个邻近对等方发送块

## CDN

### 互联网视频

视频流量占据着互联网大部分的带宽
视频是以一种恒定速率展现的图像，一幅未压缩、数字编码的图像由像素阵列组成，每个像素是由一些比特编码来表示亮度和颜色。
通过使用图像内和图像间的冗余来降低编码的比特数，视频能够被压缩，因而可用比特率(bps)来权衡视频质量。

用户观看流式视频时向服务器请求视频文件，接收的数据收集在应用缓存中，达到一定限度后应用程序开始播放视频，应用程序周期性地从缓存中抓取帧，对这些帧解压缩并且在屏幕上展现。因此，流式视频应用接收到视频就进行播放，同时缓存该视频后面部分的帧。

经 HTTP 的动态适应性流**DASH**(Dynamic Adaptive Streaming over HTTP) 将视频以不同比特率编码为几个不同的版本。客户动态地请求来自不同版本且长度为几秒的视频段数据块，根据实时带宽切换选择合适速率版本的块。
服务器通过一个**告示文件**(manifest file)为每个版本提供了一个URL及其比特率。客户端首先请求该告示文件，然后周期性地测量服务器到客户端的带宽，自适应决定请求块的时间，类型和位置，通过在HTTP GET请求报文中指定一个URL和一个字节范围获取视频的不同块。

### 内容分发网络CDN

CDN(Content Distribution Networks/Content Delivery Network)全网部署缓存服务器节点，存储服务内容，就近为用户提供服务

缓存服务器安置原则：
- enter deep：将CDN服务器部署至接近本地ISP的深入位置
- bring home：将服务器集中部署在少数关键位置，通常放置在IXP

CND在缓存服务器节点中存储内容的多个拷贝，用户请求内容时重定向到其中一个，从其中获取内容。
大多数CDN利用DNS来截获并重定向请求
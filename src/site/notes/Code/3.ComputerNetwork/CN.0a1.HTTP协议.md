---
{"dg-publish":true,"permalink":"/Code/3.ComputerNetwork/CN.0a1.HTTP协议/","title":"HTTP 协议","noteIcon":""}
---


# HTTP 协议

《图解 HTTP》阅读笔记
> [3.1 HTTP 常见面试题 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/network/2_http/http_interview.html#http-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)

## HTTP 基础知识

HTTP 协议**用于客户端和服务端之间的双向通信**，使用 *URI* 定位互联网上的资源，通过*请求报文*和*响应报文*建立通信

HTTP 协议基于 TCP 协议，默认应用端口为80
> [!attention]
> HTTP/3改用UDP协议

### HTTP报文

#### 报文内容

请求报文是由*请求方法*、*请求 URI*、*协议版本*、*可选的请求首部字段*和*内容实体*构成的，编码格式为ASCII

![|600](https://image.jiang849725768.asia/2022/202211202049360.png)

响应报文基本上由*协议版本*、*状态码*(表示请求成功或失败的数字代码)、*用以解释状态码的原因短语*、*可选的响应首部字段*以及*实体主体*构成

![|600](https://image.jiang849725768.asia/2022/202211202054456.png)

*请求报文*：
- 报文首部
	- 请求行 - **用于请求的方法，请求 URI 和 HTTP 版本**
	- 请求首部字段 - 从客户端向服务器端发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息
	- 通用首部字段 - 请求报文和响应报文两方都会使用的首部
	- 实体首部字段 - 针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息
	- 其他 - 包含 HTTP 的 RFC 里未定义的其他首部(Cookie 等)
- 空行(CR+LF) - CR：回车符；LF：换行符
- 报文主体(**非必需**)

*响应报文*：
- 报文首部
	- 状态行 - **HTTP 版本，表明响应结果的状态码和原因短语**
	- 响应首部字段 - 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。
	- 通用首部字段
	- 实体首部字段
	- 其他
- 空行(CR+LF)
- 报文主体(**非必需**)

*报文(message)*：HTTP 通信中的基本单位，由**8位组字节流**(octet sequence，其中 octet 为 8 个比特)组成，通过 HTTP 通信传输。
*实体(entity)*：作为请求或响应的有效载荷数据(补充项)被传输，其内容由*实体首部*和*实体主体*组成。

**通常，报文主体等于实体主体**，传输中进行编码操作时实体主体的内容发生变化

##### 首部字段

HTTP 首部字段格式为 `{首部字段名}: {字段值}`
首部字段用于给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。
对单一报文中相同首部字段名重复出现的处理在规范内尚未明确，依赖于浏览器的内部处理逻辑
标准中没有对每个协议头字段的名称和值的大小设置任何限制，也没有限制字段的个数。然而，出于实际场景及安全性的考虑，**大部分的服务器、客户端和代理软件都会实施一些限制**

HTTP 首部字段根据是否缓存代理分成 2 种类型：
- *端到端首部*(End-to-end Header)
	- 此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。
- *逐跳首部*(Hop-by-hop Header)
	- 此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。*HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。*
	- HTTP/1.1中的逐跳首部字段：Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade

**常见首部字段**：
- `Host` - 客户端发送时指定服务端的域名
- `Content-Length` - 服务端响应时告知数据长度
- `Content-Type`  - 服务器响应时告知数据格式
- `Content-Encoding` - 服务器响应时告知数据压缩方法
- `Connection` - 客户端要求服务器使用*HTTP 长连接*机制

具体的首部字段内容及说明可查阅 [HTTP头字段-维基百科](https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%9E%E6%A0%87%E5%87%86%E5%9B%9E%E5%BA%94%E5%AD%97%E6%AE%B5)

请求报文首部示例：

```http
GET / HTTP/1.1
Host: hackr.jp
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0.8
Accept-Language: ja,en-us;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
```

响应报文首部示例：

```http
HTTP/1.1 200 OK
Date: Fri,13 Jul 2012 02:45:26 GMT
Server: Apache
Last-Modified: Fri,31 Aug 2007 02:02:20 GMT
BTag: "45bae1-16a-46d776ac"
Accept-Ranges: bytes
Content-Length: 362
Connection: close
Content-Type: text/html
Content-Encoding: gzip
```

##### HTTP请求方法

常见HTTP方法包括：

|  方法   |                     作用                     |   协议   |
|:-------:|:--------------------------------------------:|:--------:|
|   GET   |             从服务器获取指定资源             | 1.0、1.1 |
|  POST   | 根据请求负荷(报文 body)对指定的资源做出处理 | 1.0、1.1 |
|  HEAD   |               获取报文首部字段               | 1.0、1.1 |
|   PUT   |                   传输文件                   | 1.0、1.1 |
| DELETE  |                   删除文件                   | 1.0、1.1 |
| OPTIONS |                 询问支持方法                 |   1.1    |
|  TRACE  |                   追踪路径                   |   1.1    |
| CONNECT |            要求用隧道协议连接代理            |   1.1    |
|  PATCH  |              对资源应用部分修改              |   1.1    |

GET 方法是**安全且幂等**的，无论操作多少次，服务器上的数据都安全且每次的结果相同
所以浏览器可以对 GET 请求的数据做缓存，而且在浏览器中 GET 请求可以保存为书签
POST 是新增或提交数据的操作，会修改服务器上的资源，所以是**不安全且非幂等的**
所以浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签


<div class="transclusion internal-embed is-loaded"><div class="markdown-embed">



## 幂等

假如在不考虑诸如错误或者过期等问题的情况下，若干次请求的副作用与单次请求相同或者根本没有副作用，那么这些请求方法就能够被视作“**幂等**”的


</div></div>


GET，HEAD，PUT 和 DELETE 方法都有幂等属性，同样由于根据协议，OPTIONS，TRACE 都不应有副作用，因此也理所当然也是幂等的

> [!Notes]
>   GET 请求可以携带 body ，RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body

HTTP 的 GET 请求不一定具有幂等性，在实际应用中，GET 请求通常用于获取资源的操作，例如读取文章、获取用户信息等。如果 GET 请求只是获取资源，不对资源状态做出修改，则可以确保具有幂等性。也就是说，多次发起相同的 GET 请求，得到的响应结果应该是相同的
但是，如果 GET 请求携带了一些参数，比如在 URL 中添加了时间戳或随机数等不同的标识符，那么每次请求得到的结果可能不同，因此 GET 请求就不具有幂等性

此外，一些 web 应用程序可能会在 GET 请求中使用类似于购买商品或者转帐等修改资源状态的操作，这样的 GET 请求就不具有幂等性，因为相同的请求可能会对资源状态做出不同的修改

总之，GET 请求是否具有幂等性取决于具体的场景和实现。在编写 web 应用程序时，需要根据具体的需求和场景来确定请求的幂等性。

##### HTTP状态码

|     |              类别               |                               原因短语                                |
|:---:|:-------------------------------:|:---------------------------------------------------------------------:|
| 1XX |  Informational (信息性状态码)   |                          接收的请求正在处理                           |
| 2XX |      Success (成功状态码)       |                           请求正常处理完毕                            |
| 3XX |   Redirection (重定向状态码)    | 客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源 |
| 4XX | Client Error (客户端错误状态码) |                 客户端发送的报文有误，服务器无法处理                  |
| 5XX | Server Error (服务器错误状态码) |        客户端请求报文正确，但是服务器处理时内部发生了错误         |

**常见状态码**：
- *200 OK* 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据
- *204 No Content* 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据
- *206 Partial Content* 是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态

- *301 Moved Permanently* 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问
- *302 Found* 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问
- *304 Not Modified* 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制

- *400 Bad Request* 表示客户端请求的报文有错误，但只是个笼统的错误
- *403 Forbidden* 表示服务器禁止访问资源，并不是客户端的请求出错
- *404 Not Found* 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端

- *500 Internal Server Error* 与 400 类型相似，是个笼统通用的错误码
- *501 Not Implemented* 表示客户端请求的功能还不支持
- *502 Bad Gateway* 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误
- *503 Service Unavailable* 表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思

具体代码及含义可直接查阅[HTTP 状态代码概述 - Internet Information Services | Microsoft Learn](https://learn.microsoft.com/zh-cn/troubleshoot/developer/webapps/iis/www-administration-management/http-status-code)

### 数据传输

需传输的数据编码压缩后，分块传输，由客户端进行解码恢复
- 常见内容编码包括：
	- **gzip**(GNU zip)
	- **compress**(UNIX 系统的标准压缩)
	- **deflate**(zlib)
	- **identity**(不进行编码)
- 块使用十六进制标记大小，实体主体的最后一块会使用“0(CR+LF)”来标记

对于包含多种数据类型的实体，采用*多部分对象集合*并在首部字段中加入`Content-type`
- 多部分对象集合的每个部分类型中，都可以含有首部字段
- 可以在某个部分中嵌套使用多部分对象集合

对于断连后的重新传输，可以**通过范围请求指定下载的实体范围**，仅请求部分资源，请求报文首部字段包含`Range`

#### HTTP 缓存

> [HTTP 缓存-小林 coding](https://xiaolincoding.Com/network/2_http/http_interview.Html#http-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF)

可将一些具有重复性的 HTTP 请求及其响应缓存在本地以提升性能

##### 强制缓存

*强制缓存*指只要浏览器判断缓存没有过期，则直接使用本地缓存
强制缓存利用 HTTP 首部字段中的 `Cache-Control` (相对时间)和 `Expires` (绝对时间)字段实现，它们都用来表示资源在客户端缓存的有效期：
如果 HTTP 响应头部同时有 `Cache-Control` 和 `Expires` 字段的话，**`Cache-Control` 的优先级高于 `Expires`**

`Cache-control` 选项更多一些，设置更加精细，所以建议使用 `Cache-Control` 来实现强制缓存
具体的实现流程如下：
- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在响应报文头部加上 `Cache-Control` 设置过期时间大小
- 浏览器再次请求访问服务器中的该资源时，**先通过请求资源的时间与 `Cache-Control` 中设置的过期时间大小计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器
- 服务器再次收到请求后，通过响应报文再次更新`Cache-Control`

##### 协商缓存

*协商缓存*指客户端与服务端协商之后，通过协商结果来判断是否使用本地缓存
协商缓存的响应报文状态码为304，有两种实现方式
1. 通过请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
    - `Last-Modified`：标示这个响应资源的最后修改时间
    - `If-Modified-Since`：当资源过期时，浏览器发现响应头中有 `Last-Modified` 声明，则再次发起请求的时候使用 `If-Modified-Since` 告知服务器 `Last-Modified` 值，服务器将其与被请求资源的最后修改时间进行对比
        - 如果最后修改时间较新(大)，说明资源又被改过，则返回最新资源，HTTP 200 OK
        - 如果最后修改时间较旧(小)，说明资源无新修改，响应 HTTP 304 走缓存
2. 通过请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段实现
    - `Etag`：唯一标识响应资源
    - `If-None-Match`：当资源过期时，浏览器发现响应头里有 `Etag`，则再次发起请求时使用 `If-None-Match` 告知服务器 `Etag` 值，服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200

相较于 `Last-Modified`，**`ETag` 有如下优势**：
1. 可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题
2. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次
3. 有些服务器不能精确获取文件的最后修改时间

协商缓存需要配合强制缓存中 `Cache-Control` 字段使用，**只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**

> ![http缓存.png (1348×1122) (xiaolincoding.com)|600](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png)

### 状态管理

>  [图解|cookie、session、token的那些事儿 - 掘金 (juejin.cn)](https://juejin.cn/post/7064953803564384263#heading-4)

**HTTP 协议为无状态协议**，不对之前发生过的请求和响应的状态进行管理，需使用*Cookies*记录状态

#### Cookies

**客户端和服务端首次通信时**，服务器端通过响应报文内的 `Set-Cookie` 的首部字段信息(格式为 `key=value`)通知客户端保存服务器发送的 Cookie
下次客户端向该服务器发送请求时自动在请求报文中加入 Cookie 值后发送，服务端检查 Cookie 获取状态信息

服务器有时会在响应头里添加多个 Set-Cookie，但客户端发送时不需要用多个 Cookie 字段，只要在一行里用 `;` 隔开就行
> ![|600](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/assets/9f6cca61802d65d063e24aa9ca7c38a4.png)

由于 Cookie 通常记录客户的关键识别信息，需要使用**属性**来保护，防止外泄或窃取
- 有效期
  - `Expires` - 失效的绝对时间
  - `Max-Age` - 优先采用，失效的相对时间
- 作用域
  - `Domain` - 指定 Cookie 所属的域名
  - `Path` - 指定 Cookie 所属的路径
- 安全性
  - `HttpOnly`  - 告诉浏览器此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问
  - `SameSite` - 防范*跨站请求伪造*(XSRF)攻击，`SameSite=Strict`可以严格限定 Cookie 不能随着跳转链接跨站发送，而`SameSite=Lax`允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送
  - `Secure` - 表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送，但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在

Cookie 应用：
- **身份识别** - 最基本的用途，保存用户的登录信息，实现会话事务
- **广告跟踪** - 广告商网站(例如 Google)为用户设置 Cookie 以使广告用 Cookie 读出用户身份推出定制广告，这种 Cookie 不是由访问的主站存储的，所以又叫*第三方 Cookie*(third-party cookie)

#### Session

如果说 Cookie 是客户端行为，那么 Session 就是服务端行为
Cookie 机制在最初和服务端完成交互后，保持状态所需的信息都将存储在客户端，后续直接读取发送给服务端进行交互
Session 代表服务器与浏览器的一次会话过程，将用户的所有活动信息、上下文信息、登录信息等都存储在服务端，只是生成一个唯一标识 ID 发送给客户端，后续的交互将没有重复的用户信息传输，取而代之的是唯一标识 ID

1. 当客户端第一次请求 session 对象时候，服务器会为客户端创建一个 session，并将通过特殊算法算出一个 session 的 ID，用来标识该 session 对象
2. 当浏览器下次请求别的资源的时候，浏览器会将 sessionID 放置到请求头中，服务器接收到请求后解析得到 sessionID，服务器找到该 id 的 session 来确定请求方的身份和一些上下文信息

session 的实现方式包括 **Cookie** 和 **url 重写**
cookie 为首选方式，url 重写则在禁止 cookie 的情况下提供服务，将会话标识号以参数形式附加在超链接的 URL 地址后面的技术称为 URL 重写

**问题：**
- Session 信息存储在服务端占用空间，因此如果用户量很大的场景，Session 信息占用的空间不容忽视
- 对于集群化&分布式的服务器配置，需要引入高可用的 Session 集群方案，引入 Session 代理实现信息共享，或者实现定制化哈希使用户负载均衡后始终访问同一节点

#### Token - JWT

Token 是由服务端生成并发放给客户端，具有时效性的一种验证身份的手段
原理是服务器认证以后生成一个 JSON 对象发回给用户，之后用户与服务端通信的时候，都发回这个 JSON 对象，服务器完全依赖该对象认定用户身份
Token 避免了 Session 机制带来的海量信息存储问题，也避免了 Cookie 机制的一些安全性问题，属于典型的时间换空间

> ![|625](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b93c9ae060ae4d23ba6ed98b45db5c10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

1. 客户端将用户的账号和密码提交给服务器
2. 服务器对其进行校验，通过则生成一个 token 值，将其保存在数据库，同时也返回给客户端，作为后续的请求交互身份令牌
3. 客户端拿到服务端返回的 token 值后，可将其保存在本地，以后每次请求服务器时都携带该 token，提交给服务器进行身份校验
4. 服务器接收到请求后，解析出其中的 token，再根据相同的加密算法和参数生成 token 与客户端的 token 进行对比，一致则通过，否则拒绝服务
5. token 验证通过，服务端就可以根据该 token 中的 uid 获取对应的用户信息，进行业务请求的响应

**Token 设计**

以 JSON Web Token(JWT)为例，Token 主要由 3 部分组成：
- Header 头部信息 - 记录了使用的加密算法信息
- Payload 净荷信息 - 记录了用户信息和过期时间等
- Signature 签名信息 - 对前两部分的签名，防止数据篡改

> ![|625](https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg)

服务器生成的 JWT token 的形式为 `Header.Payload.Signature`，其中 header 和 payload 的信息不做加密，只做一般的 base64URL 编码，signature 使用 header 里指定的签名算法外加服务器密钥加密生成

之后服务端每次收到 token 后剥离出 header 和 payload 获取算法、用户、过期时间等信息，然后根据自己的密钥生成 signature，并与 token的 signature 进行一致性验证，实现用 CPU 加解密的时间换取存储空间

> JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分
> JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限，也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
> JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证
> 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输

### 返回内容

服务器存在多个相同内容的页面时，通过内容协商机制返回合适内容
*内容协商机制*指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。
内容协商以响应资源的*语言、字符集、编码方式*等作为判断的基准。

机制类型：
- 服务器驱动协商(Server-driven Negotiation)
  - 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理
- 透明协商(Transparent Negotiation)
  - 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法
- 客户端驱动协商(Agent-driven Negotiation)
  - 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择

### **TODO**跨域

跨域指的是不同源之间的资源访问，只要请求的 url 有以下不同，都属于“跨域”：
- 协议: http, https, …
- 域名
- 端口



## HTTPS

针对 HTTP 存在的部分缺点进行改进形成的扩展协议，**HTTP+ 加密(SSL) + 认证 + 完整性保护=*HTTPS***(超文本传输安全协议)
HTTPS 通过 *SSL*(安全套接层)/*TLS*(安全层传输协议)加密 HTTP 的通信内容

> *TSL* 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL/TLS

![|525](https://image.jiang849725768.asia/2022/202211261654567.png)

### HTTP 的安全问题

- **窃听风险** - 通信使用明文(不加密)，内容可能会被窃听
- **冒充风险** - 不验证通信方的身份，因此有可能遭遇伪装
- **篡改风险** - 无法证明报文的完整性，所以有可能已遭篡改

按TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视

HTTP 协议中的请求和响应不会对通信方进行确认，导致问题：
- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器
- 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端
- 无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息，只想发给特定用户通信的权限
- 无法判定请求是来自何方、出自谁手。即使是无意义的请求也会照单全收
- 无法阻止海量请求下的 DoS 攻击(拒绝服务攻击)

请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为**中间人攻击**(MITM)
使用 HTTP 协议确定报文完整性常用的是 **哈希算法生成散列值**进行校验，以及用来确认文件的以 *PGP*创建的*数字签名*校验
HTTP 下用户需要亲自使用上述方法进行验证，同时无法意识到针对 PGP 和 MD5的篡改

### HTTPS 安全保证

SSL/TLS 协议可以很好地解决上述风险：
- **信息加密**：交互信息无法被窃取
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示
- **身份证书**：网站的身份可以得到证明

具体的操作方式：
- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险

#### 混合加密

- *非对称加密*又称*公开密钥加密*，使用一对非对称的密钥(*私有密钥*&*公开密钥*)进行加密，两个密钥可以双向加解密
  - 公钥加密，私钥解密：**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容
  - 私钥加密，公钥解密：**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的
*- 对称加密*也被叫做共享密钥加密，加密和解密同用一个密钥

- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

HTTPS 采用**共享密钥加密和公开密钥加密两者并用**的*混合加密*机制
- 建立通信时交换密钥环节使用公开密钥非对称加密
- 通信过程中交换报文阶段则使用共享密钥加密

#### 摘要算法&数字签名

应用层发送数据时会附加用摘要算法(哈希函数)生成的报文摘要
通过比对报文摘要能够查知报文是否遭到篡改，从而保护报文的完整性

但是摘要算法不保证报文内容和哈希值没有被中间人整体替换，可以通过**私钥加密报文摘要，公钥解密**的方法确认消息来源可信，这种方法又被称为*数字签名算法*

#### 身份证书

公开密钥的有效性通过由数字证书认证机构和其相关机关颁发的*公开密钥证书*来验证

*数字证书认证机构*(CA)为可信赖的第三方机构
1. 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打包，然后对这些信息进行 Hash 计算，得到一个 Hash 值
2. 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是数字签名
3. 最后将 Certificate Signature 添加在文件上，形成数字证书，然后分配该公开密钥
4. CA 使用自己的私钥对服务端申请的公开密钥做数字签名，将该公开密钥放入公钥证书后绑定在一起

**多数浏览器内部事先植入常用CA的公开密钥**
1. 客户端使用 CA 的公开密钥验证服务端数字证书上的签名
2. 验证成功后客户端从数字证书获取服务端公钥，加密报文后发送
3. 服务端使用私钥解密报文获取报文

> ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的
证书链的目的是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题
> ![证书链.png (1478×452) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E9%93%BE.png)

安全性极高的认证机构可颁发*客户端证书*但仅用于特殊用途的业务，如网银系统
客户端证书**只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性**

*EV SSL 证书*可确认对方服务器背后运营的企业是否真实存在
每个人都可以用开源程序OpenSSL构建属于自己的认证机构，从而自己给自己颁发服务器证书，由自认证机构颁发的证书称为**自签名证书**

### TLS 握手流程

基本流程：
1. 客户端向服务器索要并验证服务器的公钥
2. 双方协商生产会话秘钥
3. 双方采用会话秘钥进行加密通信

![](https://image.jiang849725768.asia/2022/202211261754805.png)
- CBC 模式(Cipher Block Chaining)又名密码分组链接模式

#### TLS1.2

TLS1.2 的握手阶段涉及四次通信，使用不同的密钥交换算法的流程不同，现在常用的密钥交换算法有两种：*RSA 算法* 和 *ECDHE 算法*

##### RSA

RSA 算法握手具体流程：
1. 第一次握手，客户端向服务器发起加密通信  `Client Hello`  请求
        - 客户端支持的 TLS 协议版本
        - 客户端生产的随机数 `Client Random`
        - 客户端支持的密码套件列表，如 RSA 加密算法
2. 第二次握手，服务端响应请求
    1. `Sever Hello`
          - 确认支持 TLS 协议的版本(不支持时关闭加密通信)
          - 服务器生产的随机数 `Server Random`
          - 确认的密码套件，如 RSA 加密算法
    2. `Server Hello Done`
        - 告知客户端内容发送完毕
    3. `Server Certificate`
        - 服务器的数字证书
3. 客户端通过 CA 公钥验证数字证书，取出服务器公钥，生成一个随机数 `pre-master`，进而通过协商的加密算法生成会话密钥
4. 第三次握手，客户端向服务器发送报文
    1. `Cilent Key Exchange`
        - 以服务器公钥加密的随机数 `pre-master`
    2. `Change Cipher Spec`
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    3. `Encrypted Handshake Message（Finishd)`
        - 客户端握手结束通知，表示客户端的握手阶段已经结束，同时将之前所有内容生成摘要，用会话密钥加密供服务端校验
5. 服务器通过协商的加密算法计算出本次通信的会话秘钥
6. 第四次握手，服务器响应报文
    1. `Change Cipher Spec`
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    2. `Encrypted Handshake Message`
        - 服务器握手结束通知，表示服务器的握手阶段已经结束，同时将之前所有内容生成加密摘要供客户端校验

服务器和客户端**用双方协商的加密算法对过程中交换的三个随机数 `Client Random`、`Server Random`、`pre-master key` 进行加密**，各自生成相同的*会话秘钥(共享密钥)* 用于本次通信的对称加密

基于 RSA 算法的 HTTPS 存在**前向安全问题**：**如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解**

##### ECDHE

> [!Note] DH
> ![离散对数.png (692×227) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png)
> 通过离散对数，确认 a 与 p 值后，以 i 为私钥可以计算出公钥 b，目前的计算机能力无法做到由 b 反推 i
> 客户端与服务端交流确认相同的 a 与 p 值，各自生成私钥 $i_c$、$i_s$，进而计算出各自公钥 $b_c$、$b_s$，交换公钥后可以计算出相同的结果 K
> $$ K={b_s}^{i_c}(mod\ p)=(a^{i_s})^{i_c}(mod\ p)=(a^{i_c})^{i_s}(mod\ p)= {b_c}^{i_s}(mod\ p)$$
> K 即为客户端与服务端之间的**对称加密密钥**，可以作为会话密钥使用

**为实现前向安全，每次通信随机生成私钥**，但计算量大，性能不佳
*ECDHE 算法*通过 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥
1. 双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数公开不加密
2. 双方各自随机生成一个随机数作为私钥 d，并与基点 G 相乘得到公钥 `Q = dG`，此时客户端的公私钥为 Q1 和 d1，服务器的公私钥为 Q2 和 d2
3. 双方交换各自的公钥，最后客户端计算点 `(x1，y1) = d1Q2`，服务器计算点 `(x2，y2) = d2Q1`，由于椭圆曲线满足乘法交换和结合律，所以 `d1Q2 = d1d2G = d2d1G = d2Q1` ，因此双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥

ECDHE 算法握手具体流程：
1. 第一次握手
    1. 客户端向服务器发起加密通信 ` Client Hello ` 请求
        - 客户端支持的 TLS 协议版本
        - 客户端生产的随机数 `Client Random`
        - 客户端支持的密码套件列表
2. 第二次握手，**服务器生成随机数作为服务端椭圆曲线的私钥
    1. `Sever Hello`
        - 确认支持 TLS 协议的版本(不支持时关闭加密通信)
        - 服务器生产的随机数 `Server Random`
        - 确认的密码套件
    2. `Server Certificate`
        - 服务器的数字证书
    3. `Server Key Exchange`
        - 选择的椭圆曲线类型(同时确定了基点G)
        - 根据基点 G 和私钥计算出的服务端的椭圆曲线公钥(用 RSA 签名算法进行数字签名)
    4. `Server Hello Done`
        - 告知客户端内容发送完毕
3. 客户端通过 CA 公钥验证服务器身份，**生成一个随机数作为客户端椭圆曲线的私钥，进而生成客户端的椭圆曲线公钥**，同时通过协商的加密算法生成会话密钥
4. 第三次握手
    1. 客户端向服务器发送 `Cilent Key Exchange` 报文
        - 客户端椭圆曲线公钥
    2. 客户端向服务器发送 `Change Cipher Spec` 报文
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    3. 客户端向服务器发送 `Encrypted Handshake Message（Finishd)` 报文
        - 客户端握手结束通知，表示客户端的握手阶段已经结束，同时将之前所有内容生成摘要，用会话密钥加密供服务端校验
5. 服务器通过协商的加密算法计算出本次通信的会话秘钥
6. 第四次握手
    1. 服务器向客户端发送 `Change Cipher Spec` 报文
        - 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信
    2. 服务器向客户端发送 `Encrypted Handshake Message` 报文
        - 服务器握手结束通知，表示服务器的握手阶段已经结束，同时将之前所有内容生成加密摘要供客户端校验

#### TLS1.3

TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，只需 1 RTT 就能完成 TLS 握手

> ![tls1.2and1.3.png (1832×1290) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls1.2and1.3.png)

具体做法：
1. 客户端在第一次握手时的 `Client Hello` 消息里带上了支持的椭圆曲线以及这些椭圆曲线对应的公钥
2. 服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端生成的公钥
3. 二者生成会话密钥进行加密通信

此外 TLS1.3 对于密钥交换算法废除了不支持前向安全性的 RSA 和 DH 算法，**只支持 ECDHE 算法**

#### TLS 优化

##### 会话复用

*Session ID*
客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识
当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信
为了安全性，内存中的会话密钥会定期失效
缺点：
- 服务器必须保持每一个客户端的会话密钥，随着客户端的增多，**服务器的内存压力也会越大**
- 现在网站服务一般是由多台服务器通过负载均衡提供服务的，**客户端再次连接不一定会命中上次访问过的服务器**，于是还要走完整的 TLS 握手过程

*Session Ticket*
服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端
客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket
客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信

对于集群服务器的话，要确保每台服务器加密会话密钥的密钥是一致的，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话

Session ID 和 Session Ticket 都**不具备前向安全性**，一旦加密会话密钥的密钥被破解或者服务器泄漏会话密钥，前面劫持的通信密文都会被破解

同时应对*重放攻击*也很困难

*Pre-shared Key*

重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端

Pre-shared Key 也有重放攻击的危险

> [!Note] 重放攻击
> ![重放攻击](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB.png)
> 假设 Alice 想向 Bob 证明自己的身份。 Bob 要求 Alice 的密码作为身份证明，爱丽丝应尽全力提供(可能是在经过如哈希函数的转换之后)。与此同时，Eve 窃听了对话并保留了密码(或哈希)
> 交换结束后，Eve(冒充 Alice )连接到 Bob。当被要求提供身份证明时，Eve 发送从 Bob 接受的最后一个会话中读取的 Alice 的密码(或哈希)，从而授予 Eve 访问权限
> 重放攻击的危险之处在于，如果中间人截获了某个客户端的 Session ID 或 Session Ticket 以及 POST 报文，而一般 POST 请求会改变数据库的数据，中间人就可以利用此截获的报文，不断向服务器发送该报文，这样就会导致数据库的数据被中间人改变了，而客户是不知情的
>避免重放攻击的方式就是需要**对会话密钥设定一个合理的过期时间**

### 应用数据完整性

TLS 在实现上分为*握手协议*和*记录协议*两层：
- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据
- TLS 记录协议负责**保护应用程序数据并验证其完整性和来源**，所以对 HTTP 数据加密是使用记录协议

具体流程：
1. 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩
2. 接下来，经过压缩的片段会被加上消息认证码(哈希值)以保证完整性并进行数据的认证，通过附加消息认证码的 MAC 值，可以识别出篡改，与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码
3. 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密
4. 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据

### HTTPS存在的问题

- 由于需要加密以及解密，HTTPS 的速度往往慢于 HTTP
- 进行SSL通信导致通信量的增加
- 服务端和客户端进行的加密解密消耗了时间，加大了主机的负担

## HTTP 发展

### HTTP/1.1

#### 优点

HTTP 最突出的优点是**简单、灵活和易于扩展、应用广泛和跨平台**

- 简单
  HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。
- 灵活和易于扩展
  HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**
  同时 HTTP 由于是工作在应用层( `OSI` 第七层)，则它**下层可以随意变化**，比如：
  - HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层
  - HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议
- 应用广泛，跨平台
  互联网发展至今，HTTP 的应用范围非常的广泛，同时天然具有**跨平台**的优越性

HTTP/1.1 VS HTTP/1.0 ：
- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道化网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间

#### 缺点

- 无状态
- 明文传输
- 不安全

#### 性能

HTTP/1.1 和部分 HTTP/1.0使用*持久连接(长连接)*，客户端和服务端任意一端提出断开前保持 TCP 连接，HTTP/1.1中所有链接默认为持久连接

HTTP/1.1中可使请求以*管线化*(pipelining)方式发送，实现同时并行发送多个请求，新请求的发送不需要等待上一个请求对应响应的接收
**管线化解决了请求的队头阻塞，但是没有解决响应的队头阻塞**，服务器必须按照接收请求的顺序发送对这些管道化请求的响应
**实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持**

性能瓶颈：
- 一条连接上只可发送一个请求
- 请求 / 响应首部未经压缩就发送，首部信息越多延迟越大，只能压缩 Body 的部分
- 每次互相发送相同的首部造成的浪费较多
- 没有请求优先级控制
- 请求只能从客户端开始，服务器只能被动响应
- 管线化未充分解决阻塞问题
	- 只有幂等的请求比如 GET、HEAD 才能使用 pipelining ，非幂等请求比如 POST 则不能使用，因为请求之间可能存在先后依赖关系
	- 队头阻塞问题并没有完全解决，因为服务器返回的响应还是要依请求顺序先发先回
	- 绝大多数 HTTP 代理服务器不支持 pipelining
	- 浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞

### HTTP/2

> [!Cite]  参考
> [HTTP/2 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/HTTP/2)
> [再过五分钟，你就懂 HTTP 2.0 了！_程序员cxuan的博客-CSDN博客](https://cxuan.blog.csdn.net/article/details/120037166)
> [HTTP/2 相比 1.0 有哪些重大改进？ - leozhang2018的回答 - 知乎](https://www.zhihu.com/question/34074946/answer/75364178)
> [Http系列(二) Http2中的多路复用 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903935648497678)

*HTTP/2*(超文本传输协议第2版，最初命名为*HTTP 2.0*)，简称为*h2*(基于 TLS/1.2或以上版本的加密连接)或*h2c*(非加密连接)

>HTTP/2的设计本身允许非加密的 HTTP 协议，也允许使用 TLS 1.2或更新版本协议进行加密，但多数客户端只会实现通过 TLS 加密的 HTTP/2协议，使得**经 TLS 加密的 HTTP/2成为了事实上的强制标准**，而 h2c 事实上被主流浏览器废弃

#### 起源: SPDY

HTTP 的瓶颈：**带宽**和**延迟**

Google 在 2010 年发布了 **SPDY**(取自 SPeeDY，发音同 speedy)，SPDY 的目标在于解决 HTTP 的缺陷，即延迟和安全性
SPDY 在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL

*SPDY 功能*：
- 多路复用流 - 通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。
- 服务器主动推送数据
- 压缩 HTTP 首部
- 赋予请求优先级
- 服务器提示 - 服务器可以主动提示客户端请求所需的资源。

#### HTTP/2 优化

**基于普适性的重要前提**：
- 客户端向服务器发送请求的这种基本模型不会改变
- 原有的协议头不会改变，使用 http:// 和 https:// 的服务和应用不会做任何修改，不会有 http2://
- 使用 HTTP 1.X 的客户端和服务器可以平滑升级到 HTTP 2.0 上
- 不识别 HTTP 2.0 的代理服务器可以将请求降级到 HTTP 1.X

因此 HTTP/2创建了一个协商协议标准，即*应用层协议协商*(ALPN)，以便客户端能够从 HTTP/1.0、HTTP/1.1、HTTP/2乃至其他非 HTTP 协议中做出选择
ALPN 是一个 TLS 的扩展

##### 重要特点

- **二进制分帧**
  在应用层(HTTP/2)和传输层(TCP/UDP)之间增加一个二进制分帧层，HTTP/2在层中将所有传输的信息采用二进制格式的编码分割为更小的消息和帧(frame)，其中首部信息封装到 HEADERS frame，内容实体则封装到 DATA frame
	![](https://image.jiang849725768.asia/2022/202211272107027.png)
- **多路复用**
  HTTP/2所有请求都是通过一个 TCP 连接并发完成，**将一个 TCP 连接分为若干 stream**，每个 stream 传输若干 message，每个 message 由若干二进制 frame 组成
  接收方根据不同 frame 首部唯一的 stream id 标识符区分不同的 HTTP 请求，重新将报文连接组装
  HTTP/2可以对不同的 stream 设置不同的优先级，stream 之间也可以设置依赖，依赖和优先级都可以动态调整，**解决关键请求被阻塞的问题**
- **首部压缩**
  HTTP/2使用 *HPACK 压缩算法*来减少传输的 header 大小，同时通信双方各自缓存一份 header 字段表，避免重复传输 header ，减少传输内容
- **服务端推送**
  服务端可以主动向客户端发送消息，客户端和服务器**双方都可以建立 Stream**，**客户端建立的 stream id 必须是奇数，而服务器建立的 stream id 必须是偶数**
  客户端请求 html 文件时服务器可直接提供渲染页面所需 css 文件，无须客户端收到、解析页面后再提起一轮请求，节约了加载时间
  当服务端需要主动推送某个资源时会发送一个 Frame Type 为 `PUSH_PROMISE` 的 frame ，里面带了 PUSH 需要新建的 stream id

> [!Note]  帧&流
> **帧**(Frame)：
> - HTTP/2 中**数据传输的最小单位**，
> - 每一帧都包含几个字段，有*length、type、flags、stream identifier、frame playload*等，其中 type 代表帧的类型，在 HTTP/2 的标准中定义了 10 种不同的[类型](https://webconcepts.info/concepts/http2-frame-type/)
> - 传输时 **HEADERS 帧在 DATA 帧前面**
>
> **流**(Stream)：
> - 存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数**Stream ID**
> - **双向性**：同一个流内，可同时发送和接受数据
> - **有序性**：流中被传输的数据就是二进制帧。帧在流上的被发送与被接收都是按照顺序进行的
> - **并行性**：流中的二进制帧都是被并行传输的，无需按顺序等待
> - 流的创建：流可以被客户端或服务器单方面建立, 使用或共享
> - 流的关闭：流也可以被任意一方关闭
> - 为了防止两端 stream id 冲突，客户端发起的流具有奇数 id，服务器端发起的流具有偶数 id

#### HTTP/2 缺点

- 应用层协议协商导致的一次额外来回通信延迟(RTT)
- HTTP/2 基于 TCP 协议传输数据，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，出现丢包时，之后到达的所有数据只能存放在内核缓冲区里，该 TCP 连接内的所有 Stream 都被阻塞，等到该丢包数据到达时才能被 HTTP 读取

### HTTP/3

> [!Cite]  参考
> [HTTP/3 - 維基百科，自由的百科全書 (wikipedia.org)](https://zh.wikipedia.org/zh-hk/HTTP/3)
> [5分钟看懂HTTP3_文化 & 方法_Mehdi Zed_InfoQ精选文章](https://www.infoq.cn/article/whcobxfbgtphy7ijv1kp)

**HTTP/3**是第三个主要版本的 HTTP 协议。HTTP/3中弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议实现

> ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png)

#### HTTP/3优化

- **无队头阻塞**
  QUIC 同样采取多路复用和 Stream，以自身机制保证传输的可靠性，当某个 stream 发生丢包时，仅阻塞这个 stream，其他 stream 不会受到影响，因此不存在队头阻塞问题
- **更快的连接建立**
>![28-HTTP3交互次数.png (742×492) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png)
   ![|525](https://cdn.xiaolincoding.com//mysql/other/4cad213f5125432693e0e2a512c2d1a1-20230309231022316.png)

  QUIC 内部包含 TLS，仅需 1 个 RTT 就可以同时完成建立连接与密钥协商
  更进一步，在第二次连接的时候，应用数据包可以和 QUIC 握手信息(连接信息 + TLS 信息)一起发送，达到 0-RTT 的效果
- **连接迁移**
  基于 TCP 的 HTTP 在 IP 地址变化时需要重新建立 TCP 连接
  QUIC 协议**通过*连接 ID* 来标记通信的两个端点**，端点 IP 变化时可通过上下文信息(连接 ID、TLS 密钥等)复用原连接，实现连接迁移，消除重连成本

#### HTTP/3缺点

- QUIC 协议包对于旧设备会被当作 UDP 丢包
- 普及慢

## 用户身份认证

常见认证信息：密码、动态令牌、数字证书、生物认证、IC卡等

HTTP/1.1使用的认证方式：BASIC 认证(基本认证)、DIGEST 认证(摘要认证)、SSL 客户端认证、FormBase 认证(基于表单认证)等

### Basic 认证

![](https://image.jiang849725768.asia/2022/202211271047364.png)

- 安全性低，明文解码后就是用户 ID和密码
- 一般浏览器无法实现认证的注销操作

### DIGEST认证

![](https://image.jiang849725768.asia/2022/202211271054320.png)

1. ①中首部字段 `WWW-Authenticate` 内必须包含 `realm` 和 `nonce` 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。
2. ②中首部字段 `Authorization` 内必须包含 `username`、`realm`、`nonce`、`uri` 和 `response` 的字段信息。
	- `realm` 和 `nonce` 就是之前从服务器接收到的响应中的字段。
	- `username` 是 `realm` 限定范围内可进行认证的用户名
	- `uri`(digest-uri)即 `Request-URI` 的值，经代理转发后`Request-URI`的值可能被修改，因此事先会复制一份副本保存在`uri`内。
	- `response` 也可叫做 `Request-Digest`，存放经过 MD5 运算后的密码字符串，形成响应码。

### SSL客户端认证

借由 HTTPS 的客户端证书完成认证

步骤：
1. 接收到需要认证资源的请求，服务器会发送 `CertificateRequest` 报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 `Client Certificate` 报文方式发送给服务器。
3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。

多数情况下和[[Code/3.ComputerNetwork/CN.0a1.HTTP协议#表单认证\|表单认证]]组合形成一种**双因素认证**(Two-factor authentication)来使用

### 表单认证

基于表单的认证方法不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息(Credential)，按登录信息的验证结果认证。

***用户身份认证多半基于表单认证***
基于表单认证的标准规范尚未有定论，一般会使用 **Cookie** 来管理 **Session**(会话)。

1. 客户端使用HTTPS进行用户输入数据(用户名&密码)的发送
2. 服务器将用户认证状态和**Session ID**绑定后向用户发放包含Session ID的cookies
3. 之后客户端发送请求时服务器验证接收到的Cookies中的Session ID识别用户和其认证状态

服务器端应如何保存用户提交的密码等登录信息等也没有标准化，通常的安全做法是先利用给密码加盐(salt)的方式增加额外信息，再使用散列(hash)函数计算出散列值后保存。
- salt 是由服务器随机生成的一个长度足够长的字符串，和密码字符串相连接(前后都可以)生成散列值。
- 当两个用户使用了同一个密码时，由于随机生成的 salt 值不同，对应的散列值也将是不同的。

## Web 服务器

### 虚拟主机

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点，因此**利用虚拟主机可令一个IP地址配对多个URI**
互联网通过DNS服务将URI解析为IP进行连接，连接至服务器上通过首部中的`Host`指定的URI确认具体的访问域名

### 转发服务器

#### 代理/缓存

**代理服务器**(proxy server)也叫**Web缓存器**(Web cache)，其接收客户端发送的请求后转发给其他服务器。代理*不改变请求 URI*，会直接发送给前方持有资源的目标服务器。
每次通过代理服务器转发请求或响应时，会追加写入`Via`首部信息

*用途*：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等等

*类型*：**缓存/非缓存代理**、**透明/非透明代理**
代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上
转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理

**缓存服务器**是代理服务器的一种，并归类在缓存代理类型中，缓存可以存在于缓存服务器内或客户端浏览器中。判定缓存过期后，会向源服务器确认资源的有效性，若判断浏览器缓存失效，浏览器会再次请求新资源。***缓存服务器既是服务器又是客户端。*** 当它接收浏览器的请求并发回响应时是服务器。当它向初始服务器发出请求并接收响应时是客户端。

- 降低客户端响应时间
- 减轻服务器负载

对于缓存的版本问题，HTTP使用**条件GET**(conditional GET)方法，在GET方法的首部字段中加入`If-Modified-Since`字段以确认缓存文件是否改变

#### 网关

转发其他服务器通信数据的服务器

*用途*：可以由 HTTP 请求转化为其他协议通信

#### 隧道

在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序

*用途*：用 SSL 等加密手段进行通信，确保客户端能与服务器进行安全的通信

[[CN.0a1a.HTTP相关知识\|CN.0a1a.HTTP相关知识]]

---
{"dg-publish":true,"permalink":"/Code/3.ComputerNetwork/CN.0b.传输层/","title":"传输层","tags":[2,3,4],"noteIcon":""}
---


# 传输层

网络层提供了**主机之间**的逻辑通信，而传输层为**运行在不同主机上的进程之间**提供了逻辑通信功能
传输层受限于网络层提供的服务(e.g.时延和带宽)的同时，也对网络层服务进行了加强(e.g.可靠的数据传输和加密)
1. 在发送端，运输层将从应用层接收到的报文转换成为运输层报文段（segment）然后将这些报文段传递给网络层
2. 网络层将其封装成网络层分组（即数据报）并向目的地发送
3. 在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层
4. 运输层则处理接收到的报文段，使该报文段中的数据为应用层使用

互联网的主要传输层协议包括 TCP 和 UDP

TCP：
- 字节流
- 可靠数据传输
- 多路复用、解复用
- 流量控制
- 拥塞控制
- 不能提供的服务：时间保证、最小吞吐保证和安全
- 面向连接：要求在客户端进程和服务器进程之间建立连接
TCP 的安全性可通过 [[Code/3.ComputerNetwork/CN.0a1.HTTP协议#SSL客户端认证\|SSL]] 保证

UDP：
- 数据报
- 完成进程间通信
- 多路复用、解复用
- 少量差错检查
- 不做可靠性的工作，因此可提高实时性
- 没有拥塞控制和流量控制，因此应用能够按照设定的速度发送数据

## 传输层数据交互

将主机间交付扩展到进程间交付被称为传输层的**多路复用** (transport-layer multiplexing)与**多路分解**(demultiplexing)

多路复用：从多个socket(套接字)接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部信息加以封装 (该头部信息用于以后的解复用)
多路分解：TCP或UDP实体采用头部信息，将报文段的数据部分交给正确的socket，从而交给正确的进程

>[!note] 端口号
>端口号是一个16 bits 的数，其大小在0 ~ 65535之间
>0 ~ 1023范围的端口号称为*周知端口号*，使用受限制，被保留给诸如 HTTP 和 FTP 之类的周知应用层协议来使用。

无连接(UDP)情况下报文仅根据目标主机ip和目标端口号确定交付的目标socket
面向连接情况下报文根据源主机 ip，源端口，目标主机 ip 和目标端口确定目标 socket，服务器能够在一个 TCP 端口上同时支持多个有着不同的源 ip 或源 port 的 TCP 套接字

一台运行Web服务器的主机接收的所有报文段的母单端口都是80，当今的高性能Web服务器通常只使用一个进程，为每个新的客户端连接创建一个具有新连接套接字的新线程。

## 可靠数据传输

*可靠数据传输RDT*为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输
借助于可靠信道，传输数据比特不会损坏(由0变1，或者相反)或丢失，且所有数据按照发送顺序进行交付
RDT通过*可靠数据传输协议*实现，可靠数据传输协议的下层协议也许是不可靠的

若下层信道可靠 => rdt1.0
发送方：
1. 接收上层信息
2. 打包分组
3. 发送给下层信道
接收方：
1. 接收下层信息
2. 解包分组
3. 传递给上层信道

### 比特差错修正

对于下层信道传输中出现的比特受损情况，通过**自动重传请求**(Automatic Repeat reQuest, ARQ)协议解决 => rdt2.0
发送方：
1. 接收上层信息
2. 打包分组
3. 发送给下层信道
4. 等待接收方反馈
	- ACK：继续发送下一分组
	- NAK：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组
	- 正确
		1. 返回肯定确认**ACK**(positive acknowledgment)
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回否定确认**NAK**(negative acknowledgment)

> [!todo]
>除检验和外具体的分组检验方法

rdt2.0中发送方确信接收方已正确接收当前分组后发送新分组，此种协议称为**停等协议**

对分组编号，在返回ACK中包含该编号可避免ACK在传输过程中受损带来的影响，同时可以用发送一个上次正确接收的分组的ACK来替代NAK -> rdt2.2
发送方：
1. 接收上层信息
2. 打包分组0
3. 发送给下层信道
4. 等待接收方反馈
	- ACK0：继续发送下一分组
	- 乱码/ACK1：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组序号和分组正确性
	- 正确
		1. 返回ACK0
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回ACK1(上一分组的序号)

> [!attention]
>以上方法建立在下层信道传递信息时不丢失的基础上

### 数据丢失修正

发送方在一定时间未收到响应后重传分组以避免丢包带来的数据丢失 => rdt3.0
发送方：
1. 接收上层信息
2. 打包分组0
3. 发送给下层信道
4. 等待接收方反馈
	- ACK0：继续发送下一分组
	- **无响应**/乱码/ACK1：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组序号和分组正确性
	- 正确
		1. 返回ACK0
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回ACK1(上一分组的序号)

为了实现基于时间的重传机制，发送方每次发送一个分组（包括第一次分组和重传分组）时便启动一个定时器，定时器中断则重传分组，收到ACK就中止定时器

过早超时（延迟的 ACK）也能够正常工作，但是效率较低
发送方至少需要等待这样长的时间：发送方与接收方之间的一个往返时延（可能包括中间路由器的缓冲时延）加上接收方处理一个分组所需的时间

因为分组序号在0和1之间交替，因此rdt3.0有时被称为**比特交替协议**(alter-nating-bit protocol)

### 性能提升(滑动窗口)

上述停等方式使得带宽利用率低，严重影响性能。
允许发送方发送多个分组而无须等待确认，从而提高利用率，这种技术称为*流水线技术*

流水线技术需求：
- 增加序号范围，使流水线中的多个分组得以区分
- 发送方和接收方缓存多个分组以重传或排序

所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。两种通用的流水线协议包括**回退N步**(GBN)和**选择重传**(SR)

停等协议、GBN和SR都属于*滑动窗口协议*
**发送缓冲区**为内存中存储可发送分组的区域，其大小决定了一次最多可发送的未经确认的分组数(停等为1)
**发送窗口**为发送缓冲区中**已发送但是未经确认的分组**构成的空间
随着缓冲区中分组的发送，发送窗口前部扩展
随着发送缓冲区尾部分组的确认，发送缓冲区向前滑动，直至尾部到达下一个未确认分组，发送窗口尾部收缩
![](https://image.jiang849725768.asia/2022/202212182025758.png)
**接收窗口**=**接收缓冲区**，只有位于接收窗口中的分组才允许接收，其他丢弃
仅在接收到尾部分组后，接收窗口向前滑动，直至尾部到达下一个未接收分组

GBN协议中，接收窗口大小为1分组，因此接收方丢弃所有失序分组
发送方拥有发送窗口头部分组的定时器，如果出现超时，发送方需依序重传所有发送窗口内的分组
此协议接收方采用**累积确认**，对失序分组返回上一个正确分组的 ACK，所返回的序号为 x 的 ACK 表明接收方已正确接收了 x 及 x 以前的所有分组
对于 GBN 协议而言，**发送缓冲区长度必须小于分组序号空间大小**，以避免接收方无法分辨分组为新分组还是重传

SR协议中，接收窗口尺寸大于1分组，接收方缓存接收窗口中的高序号分组直至窗口尾部分组到来，然后将一批连续分组按序向上交付。
发送方为发送窗口中的每个分组保持一个定时器，如果出现超时，发送方仅重传超时的分组
此协议接收方收到分组后发送该分组的ACK，且对于重复接收到的分组依然发送ACK，以防止发送缓冲区阻塞
对于SR协议而言，*发送缓冲区长度必须小于或等于分组序号空间大小的一半*，以避免接收方无法分辨分组为新分组还是重传

GBN协议实现简单，接收方所需缓存空间少，但出错时回退N步代价较大，SR协议与之相反，因此根据不同需求选用不同协议

> [!todo]
> 缓冲区大小的限制因素：流量控制、拥塞控制
> 是否仅需保证发送方缓冲区和接收方缓冲区之和小于分组空间序号大小即可？

## UDP

用户数据报协议 UDP 不建立连接，仅将应用段报文附加首部信息后传递给网络层，在发送报文段之前，发送方和接收方的运输层实体之间没有握手

> ![|600](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png)

UDP首部信息：
- *目标和源端口*(32bit)：主要是告诉 UDP 协议应该把报文发给哪个进程
- *包长度*(16bit)：该字段保存了 UDP 首部的长度跟数据的长度之和
- *校验和*(16bit)：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包

**校验和**为发送方报文段(视为许多16bit 的整数)的加法和(进位回滚)的反码，接收方同样计算报文段的加法和，与校验和相加后理论结果为1111111111111111
校验和可以检测差错但不能保证可靠性(存在0则有差错，反之不代表没有差错){ #checksum}


优点：
- 不建立连接，因此延时少
- 不维护连接状态，服务器负载小
- 报文段头部小，传递开销少
- 无拥塞控制和流量控制，可以尽可能快的发送报文段
- 支持一对一、一对多、多对多的交互通信

问题：
- 无拥塞控制容易导致分组溢出，进而引起[[Code/3.ComputerNetwork/CN.0.计算机网络#^PacketLoss\|丢包]]，由无控制的 UDP 发送方引入的高丢包率将严重影响 TCP 发送方的传输速率

### 可靠性

> [4.17 如何基于 UDP 协议实现可靠传输？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/network/3_tcp/quic.html)

UDP 可通过在应用程序自身中建立可靠性机制来实现可靠数据传输

应用层加序列号和 ACK。然后本地会缓存一些自己已经发过的消息，然后同时也要求对方在收到消息之后返回 ACK 来确认这个消息已经收到，如果没有收到 ACK 的话，可能会设置一些定时重传的这样的一些方式，来确保这个消息能够成功的发送到对方

### 最大长度

> [为什么 UDP 数据包不能超过 512 个字节？ | 太傅博客 (taifua.com)](https://taifua.com/udp-512bytes-limit.html)

### 基于 UDP 的可靠传输

在 UDP 传输中借鉴了TCP的传输特点，通过3次握手建立连接，通过心跳维持连接，可以主动或者接收不到心跳
后断开连接从而为数据传输建立一个可靠的传输通道；在数据的传输时，通过滑动窗口以及重发机制最大效率地传输数据。

[[Code/3.ComputerNetwork/CN.0b1.TCP协议\|CN.0b1.TCP协议]]
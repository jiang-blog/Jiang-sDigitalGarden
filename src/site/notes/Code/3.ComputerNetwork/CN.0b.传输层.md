---
{"dg-publish":true,"permalink":"/Code/3.ComputerNetwork/CN.0b.传输层/","title":"传输层","noteIcon":""}
---


# 传输层

网络层提供了**主机之间**的逻辑通信，而传输层为**运行在不同主机上的进程之间**提供了逻辑通信功能
传输层受限于网络层提供的服务(e.g.时延和带宽)的同时，也对网络层服务进行了加强(e.g.可靠的数据传输和加密)
1. 在发送端，运输层将从应用层接收到的报文转换成为运输层报文段（segment）然后将这些报文段传递给网络层
2. 网络层将其封装成网络层分组（即数据报）并向目的地发送
3. 在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层
4. 运输层则处理接收到的报文段，使该报文段中的数据为应用层使用

互联网的主要传输层协议包括 TCP 和 UDP

TCP：
- 字节流
- 可靠数据传输
- 多路复用、解复用
- 流量控制
- 拥塞控制
- 不能提供的服务：时间保证、最小吞吐保证和安全
- 面向连接：要求在客户端进程和服务器进程之间建立连接
TCP 的安全性可通过 [[Code/3.ComputerNetwork/CN.0a1.HTTP协议#SSL客户端认证\|SSL]] 保证

UDP：
- 数据报
- 完成进程间通信
- 多路复用、解复用
- 少量差错检查
- 不做可靠性的工作，因此可提高实时性
- 没有拥塞控制和流量控制，因此应用能够按照设定的速度发送数据

## 传输层数据交互

将主机间交付扩展到进程间交付被称为传输层的**多路复用** (transport-layer multiplexing)与**多路分解**(demultiplexing)

多路复用：从多个socket(套接字)接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部信息加以封装 (该头部信息用于以后的解复用)
多路分解：TCP或UDP实体采用头部信息，将报文段的数据部分交给正确的socket，从而交给正确的进程

>[!note] 端口号
>端口号是一个16 bits 的数，其大小在0 ~ 65535之间
>0 ~ 1023范围的端口号称为*周知端口号*，使用受限制，被保留给诸如 HTTP 和 FTP 之类的周知应用层协议来使用。

无连接(UDP)情况下报文仅根据目标主机ip和目标端口号确定交付的目标socket
面向连接情况下报文根据源主机ip，源端口，目标主机ip和目标端口确定目标socket，服务器能够在一个TCP端口上同时支持多个有着不同的源ip或源port的TCP套接字

一台运行Web服务器的主机接收的所有报文段的母单端口都是80，当今的高性能Web服务器通常只使用一个进程，为每个新的客户端连接创建一个具有新连接套接字的新线程。

## UDP

用户数据报协议**UDP**不建立连接，仅将应用段报文附加首部信息后传递给网络层，在发送报文段之前，发送方和接收方的运输层实体之间没有握手

> ![|600](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png)

UDP首部信息：
- *目标和源端口*(32bit)：主要是告诉 UDP 协议应该把报文发给哪个进程
- *包长度*(16bit)：该字段保存了 UDP 首部的长度跟数据的长度之和
- *校验和*(16bit)：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包

**校验和**为发送方报文段(视为许多16bit 的整数)的加法和(进位回滚)的反码，接收方同样计算报文段的加法和，与校验和相加后理论结果为1111111111111111
校验和可以检测差错但不能保证可靠性(存在0则有差错，反之不代表没有差错){ #checksum}


优点：
- 不建立连接，因此延时少
- 不维护连接状态，服务器负载小
- 报文段头部小，传递开销少
- 无拥塞控制和流量控制，可以尽可能快的发送报文段
- 支持一对一、一对多、多对多的交互通信

问题：
- 无拥塞控制容易导致分组溢出，进而引起[[Code/3.ComputerNetwork/CN.0.计算机网络#^PacketLoss\|丢包]]，由无控制的 UDP 发送方引入的高丢包率将严重影响 TCP 发送方的传输速率

UDP可通过在应用程序自身中建立可靠性机制来实现可靠数据传输

## 可靠数据传输

*可靠数据传输RDT*为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输
借助于可靠信道，传输数据比特不会损坏(由0变1，或者相反)或丢失，且所有数据按照发送顺序进行交付
RDT通过*可靠数据传输协议*实现，可靠数据传输协议的下层协议也许是不可靠的

若下层信道可靠 => rdt1.0
发送方：
1. 接收上层信息
2. 打包分组
3. 发送给下层信道
接收方：
1. 接收下层信息
2. 解包分组
3. 传递给上层信道

### 比特差错修正

对于下层信道传输中出现的比特受损情况，通过**自动重传请求**(Automatic Repeat reQuest, ARQ)协议解决 => rdt2.0
发送方：
1. 接收上层信息
2. 打包分组
3. 发送给下层信道
4. 等待接收方反馈
	- ACK：继续发送下一分组
	- NAK：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组
	- 正确
		1. 返回肯定确认**ACK**(positive acknowledgment)
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回否定确认**NAK**(negative acknowledgment)

> [!todo]
>除检验和外具体的分组检验方法

rdt2.0中发送方确信接收方已正确接收当前分组后发送新分组，此种协议称为**停等协议**

对分组编号，在返回ACK中包含该编号可避免ACK在传输过程中受损带来的影响，同时可以用发送一个上次正确接收的分组的ACK来替代NAK -> rdt2.2
发送方：
1. 接收上层信息
2. 打包分组0
3. 发送给下层信道
4. 等待接收方反馈
	- ACK0：继续发送下一分组
	- 乱码/ACK1：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组序号和分组正确性
	- 正确
		1. 返回ACK0
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回ACK1(上一分组的序号)

> [!important]
>以上方法建立在下层信道传递信息时不丢失的基础上

### 数据丢失修正

发送方在一定时间未收到响应后重传分组以避免丢包带来的数据丢失 => rdt3.0
发送方：
1. 接收上层信息
2. 打包分组0
3. 发送给下层信道
4. 等待接收方反馈
	- ACK0：继续发送下一分组
	- **无响应**/乱码/ACK1：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组序号和分组正确性
	- 正确
		1. 返回ACK0
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回ACK1(上一分组的序号)

为了实现基于时间的重传机制，发送方每次发送一个分组（包括第一次分组和重传分组）时便启动一个定时器，定时器中断则重传分组，收到ACK就中止定时器

过早超时（延迟的 ACK）也能够正常工作，但是效率较低
发送方至少需要等待这样长的时间：发送方与接收方之间的一个往返时延（可能包括中间路由器的缓冲时延）加上接收方处理一个分组所需的时间

因为分组序号在0和1之间交替，因此rdt3.0有时被称为**比特交替协议**(alter-nating-bit protocol)

### 性能提升

上述停等方式使得带宽利用率低，严重影响性能。
允许发送方发送多个分组而无须等待确认，从而提高利用率，这种技术称为*流水线技术*

流水线技术需求：
- 增加序号范围，使流水线中的多个分组得以区分
- 发送方和接收方缓存多个分组以重传或排序

所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。两种通用的流水线协议包括**回退N步**(GBN)和**选择重传**(SR)

停等协议、GBN和SR都属于*滑动窗口协议*
**发送缓冲区**为内存中存储可发送分组的区域，其大小决定了一次最多可发送的未经确认的分组数(停等为1)
**发送窗口**为发送缓冲区中**已发送但是未经确认的分组**构成的空间
随着缓冲区中分组的发送，发送窗口前部扩展
随着发送缓冲区尾部分组的确认，发送缓冲区向前滑动，直至尾部到达下一个未确认分组，发送窗口尾部收缩
![](https://image.jiang849725768.asia/2022/202212182025758.png)
**接收窗口**=**接收缓冲区**，只有位于接收窗口中的分组才允许接收，其他丢弃
仅在接收到尾部分组后，接收窗口向前滑动，直至尾部到达下一个未接收分组

GBN协议中，接收窗口大小为1分组，因此接收方丢弃所有失序分组
发送方拥有发送窗口头部分组的定时器，如果出现超时，发送方需依序重传所有发送窗口内的分组
此协议接收方采用**累积确认**，对失序分组返回上一个正确分组的 ACK，所返回的序号为 x 的 ACK 表明接收方已正确接收了 x 及 x 以前的所有分组
对于 GBN 协议而言，**发送缓冲区长度必须小于分组序号空间大小**，以避免接收方无法分辨分组为新分组还是重传

SR协议中，接收窗口尺寸大于1分组，接收方缓存接收窗口中的高序号分组直至窗口尾部分组到来，然后将一批连续分组按序向上交付。
发送方为发送窗口中的每个分组保持一个定时器，如果出现超时，发送方仅重传超时的分组
此协议接收方收到分组后发送该分组的ACK，且对于重复接收到的分组依然发送ACK，以防止发送缓冲区阻塞
对于SR协议而言，*发送缓冲区长度必须小于或等于分组序号空间大小的一半*，以避免接收方无法分辨分组为新分组还是重传

GBN协议实现简单，接收方所需缓存空间少，但出错时回退N步代价较大，SR协议与之相反，因此根据不同需求选用不同协议

> [!todo]
> 缓冲区大小的限制因素：流量控制、拥塞控制
> 是否仅需保证发送方缓冲区和接收方缓冲区之和小于分组空间序号大小即可？

## TCP

### 概述

TCP 是**面向连接的、可靠的、基于字节流的**传输层通信协议
- **面向连接**
  单个发送方与单个接收方进行连接，在发送数据前两个进程需要先进行握手(交换控制报文)建立连接(初始化发送方、接收方的状态变量)
- **可靠**
  无论的网络链路中出现了怎样的链路变化，TCP 都可以**保证一个报文一定能够到达接收端
- **基于字节流**
  TCP 将数据看成一个无结构的、有序的流，用户消息通过 TCP 协议传输时可能会被操作系统分组成多个的 TCP 报文进入流中，接收方程序必须**知道消息的边界**以读出一个有效的用户消息
  **TCP 报文是有序的**，当前一个 TCP 报文没有收到的时候持续等待，同时对重复的 TCP 报文自动丢弃

#### 报文格式

> ![|575](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

TCP 首部信息：
- *源端口号*(16bit)
- *目标端口号*(16bit)
- *序列号*(32bit) - 报文段首字节在字节流中的编号
- *确认号*(32bit) - 期望从另一方收到的下一个字节的序号
- *接收窗口*(16bit) - 愿意接收的字节数量
- *首部长度/数据偏移*(4bit) - 以32bit的字为单位的TCP首部长度
- 保留字段(6bit) - 保留为今后使用，不使用
- *标志字段*(6bit)
	- *ACK* - 指示确认应答字段值的有效性
	- *RST*、*SYN*和*FIN* - 用于连接建立和断开
	- URG - 紧急数据，不使用
	- PSH - 马上推出(立即上交)数据，不使用
- *校验和*(16bit)
- 紧急数据指针(16bit) - 不使用
- *选项*(不定长)
- *填充* - 使整个首部长度是整数个字(32bit)

TCP隐式地对字节流中的每一个字节编号，*序列号*是当前报文段首字节的字节流编号，*确认号*为希望对方主机发送的下一报文段所含数据的首字节的编号
序号到达2^32-1后重新从0开始
一条 TCP 连接的双方均可随机地选择初始序列号，这样做可以减少两台主机的新建连接受到仍在网络中存在的过期连接的报文段的影响

TCP 将数据依照*最大报文段长度*(MSS)分割，加上 TCP 首部后形成多个 TCP 报文段，然后下发至网络层

> [!note] MSS
> MSS通常根据最初确定的由本地发送主机发送的*最大链路层帧长度*(即所谓的最大传输单元(MTU))来设置
> TCP 与 IP 首部长度之和通常为40bytes，以太网和 PPP 链路层协议都具有1500字节的 MTU，因此 MSS 的典型值为1460字节
> TCP 通过 MSS 保证**一个完整 TCP 报文段在 IP 层不被分片**，以免包含部分 TCP 报文段的单个 IP 分片丢失时需要重传整个 TCP 报文，开销过大
> 为了达到最佳的传输效能 TCP 协议在**建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了{ #mss}


#### TCP VS UDP

- 连接
  - TCP 是面向连接的传输层协议，传输数据前先要建立连接。
  - UDP 是不需要连接，即刻传输数据
- 服务对象
  - TCP 是一对一的两点服务，即一条连接只有两个端点
  - UDP 支持一对一、一对多、多对多的交互通信
- 可靠性
  - TCP 可靠交付数据，数据可以无差错、不丢失、不重复、按序到达
  - UDP 尽最大努力交付，不保证可靠交付数据(但是可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现可靠传输？(opens new window)
- 拥塞控制、流量控制
  - TCP 有拥塞控制和流量控制机制，保证数据传输的安全性
  - UDP 没有，即使网络非常拥堵了，也不会影响 UDP 的发送速度
- 首部开销
  - TCP 首部长度较长，在没有使用选项字段时固定为 20 bytes，使用了选项字段则不定长
  - UDP 首部固定为 8 bytes
- 传输方式
  - TCP 是流式传输，没有边界，但保证顺序和可靠
  - UDP 是一个包一个包的发送，有边界，但可能会丢包和乱序
- 分片不同
  - TCP 的数据如果大于 MSS，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片
  - UDP 本身不对数据进行分片，数据如果大于 MTU，则会在网络层进行分片，目标主机收到后，在网络层组装完数据，接着再传给传输层

### TCP 连接管理

TCP 通过*四元组*(源 IP、源端口、目的 IP、目的端口)唯一地确定一个连接
**因此客户端的端口可以被重复使用于连接不同的服务端**

> [!Tips]
> 在 Linux 可以通过 `netstat -napt` 命令查看 TCP 的连接状态
> ![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230520683.png)

#### 建立连接 - 三次握手

在正式交换数据之前，发送方和接收方握手建立通信关系

> ![TCP三次握手.drawio.png (1221×1019) (xiaolincoding.com)|600](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

1. 客户端的 TCP 首先向服务器端的 TCP 发送一个特殊的 TCP 报文段(*SYN 报文段*)
   - 该报文段中不包含应用层数据
   - 首部字段中 SYN 置1，序列号随机初始化为 `client_isn`
   - 客户端进入 `SYN-SENT` 状态
2. 服务器接收 SYN 报文段，为 TCP 连接分配 TCP 缓存和变量，向该客户 TCP 发送允许连接的报文段(*SYNACK 报文段*)
   - 该报文段中也不包含应用层数据
   - 首部字段中 SYN 和 ACK 置1，确认号为 `client_isn+1`，序列号随机初始化为 `server_isn`
   - 服务端进入 `SYN-RCVD` 状态
3. 客户端接收 SYNACK 报文段，为 TCP 连接分配 TCP 缓存和变量，向服务端发送应答报文(*ACK 报文段*)
    - **该报文段可在主体中携带应用层数据**
    - 首部字段中 SYN 置0(连接已建立)，ACK 置1，确认号为 `server_isn+1`
    - 客户端进入 `ESTABLISHED` 状态
4. 服务端收到应答报文，进入 `ESTABLISHED` 状态

SYN 报文是特殊的 TCP 报文，虽然 SYN 报文不携带用户数据，但**TCP 将 SYN 报文视为 1 字节的数据**，当对方收到了 SYN 报文后，在回复 ACK 报文时，需要将 ACK 报文中的确认号设置为 SYN 的序列号 + 1
随机初始化序列号可防止**历史报文被下一个相同四元组的连接接收**的问题

##### 三次握手作用

- 阻止重复历史连接的初始化(**主要原因**)
- 避免资源浪费
- 同步双方的初始序列号

在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费
> ![|450](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png)

当服务端第一次收到 SYN 报文(Seq Num = 90)时，就会回复 SYN+ACK 报文(ACK Num = 91)给客户端，**如果服务端在收到 RST 报文之前，先收到了新 SYN 报文**(Seq Num = 100)，就会回 [Challenge Ack](https://xiaolincoding.com/network/3_tcp/challenge_ack.html) 报文给客户端，这个 ACK 报文的 **ACK Num = 91**，客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文

两次握手导致*半连接*和*老数据被当作新数据接收*，造成资源浪费
![|600](https://image.jiang849725768.asia/2022/202212191650984.png)

序列号是可靠传输的一个关键因素，它的作用：
- 接收方可以去除重复的数据
- 接收方可以根据数据包的序列号按序接收
- 可以标识发送出去的数据包中，哪些是已经被对方收到的(通过 ACK 报文中的序列号知道)

为了保证双方序列号都能成功到达，需要双方都进行 SYN 和 ACK，也即四次握手，服务端的 ACK 以及 SYN 可以合并，所以只需三次握手

##### 握手丢失

- 第一次握手丢失
超时重传序列号相同的 SYN 报文
- 第二次握手丢失
客户端未收到 ACK，超时重传 SYN 报文
服务端未收到 ACK，超时重传 SYN-ACK 报文
- 第三次握手丢失
**ACK 报文不会重传**，服务端未收到 ACK，超时重传 SYN-ACK 报文

Linux 里
SYN 报文最大重传次数由 `tcp_syn_retries` (default: 5)内核参数控制，通常首次超时重传的等待时间为1s，每次超时的等待时间是上一次的两倍
SYN-ACK 报文的最大重传次数由 `tcp_synack_retries` (default: 5)内核参数控制

重传达到最大次数后，再经过一次等待时间后断开连接

##### 半连接&全连接

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
- 半连接队列，也称 SYN 队列
- 全连接队列，也称 accept 队列

> ![format,png-20230309230622886.png (737×519) (xiaolincoding.com)](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png)

不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文

##### SYN 攻击

*SYN 攻击*短时间伪造不同 IP 地址的 `SYN` 报文，把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接

#### 关闭连接 - 四次挥手

> ![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

1. 请求方发送 *FIN 报文*
    - 首部 `FIN` 标志位置1
    - 请求方进入 `FIN_WAIT_1` 状态
2. 接收方收到该报文后向请求方发送 ACK 应答报文
    - 接收方进入 `CLOSE_WAIT` 状态
3. 请求方收到 ACK 应答报文后进入 `FIN_WAIT_2` 状态
4. 接收方处理完数据后，也向请求方发送FIN报文
    - 接收方进入 `LAST_ACK` 状态
5. 请求方收到 FIN 报文后向接收方发送 ACK 应答报文
    - 请求方进入 `TIME_WAIT` 状态
6. 接收方收到 ACK 应答报文后进入 `CLOSE` 状态，完成关闭
7. 请求方在经过一段时间(2MSL)后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭

##### TIME_WAIT

*报文最大生存时间*(MSL)是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
IP 头中的 `TTL` 字段控制 IP 数据报可以经过的最大路由数， **MSL 应该大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡
TTL 的值一般是 64，Linux 将 MSL 设置为 30s

作用：
- 防止历史连接中的数据被后面相同四元组的连接错误的接收
    - 2MSL 足以让两个方向上的数据包都被丢弃，使得原连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的
- 保证接收方能被正确的关闭
    - 2MSL 可以确保第四次挥手的 ACK 报文丢失后能够收到接收方重传的 FIN 报文

过多 TIME_WAIT 的危害：
- 占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；
- 占用端口资源，端口资源也是有限的，一般可以开启的端口为 32768～61000

优化：
- 开启 `net.ipv4.tcp_tw_reuse` 和 `tcp_timestamps`，使新连接可以复用处于 TIME_WAIT 的 socket
- 调节 `net.ipv4.tcp_max_tw_buckets` (default: 18000)参数，系统中处于 TIME_WAIT 的连接超出参数值时，重置溢出连接

**如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接**，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT

##### 四次握手作用

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接

从上面过程可知，**服务端通常需要等待完成数据的发送和处理**，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手

**在特定情况下，四次挥手可以变成[三次挥手](https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html)**

##### 挥手丢失

- 第一次挥手丢失
  - 请求方重传 FIN 报文，最大重传次数由 `tcp_orphan_retries` 内核参数控制，达到最大重传次数后，再经过一次等待时间后断开连接
- 第二次挥手丢失
  - 与第一次相同
- 第三次挥手丢失
  - 接收方重发 FIN 报文，重发次数仍然由 `tcp_orphan_retries` 参数控制
  - 请求方
    - 对于 close 函数关闭的连接
       由于无法再发送和接收数据，所以请求方的 `FIN_WAIT2` 状态不可以持续太久， `tcp_fin_timeout` (default: 60s)内核参数控制了这个状态下连接的持续时长
    - 对于 shutdown 函数关闭的连接
       如果请求方使用 shutdown 函数关闭写连接(只关闭发送方向)且一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 `FIN_WAIT2` 状态
- 第四次挥手丢失
  - 接收方重发 FIN 报文，达到最大重传次数后，再经过一次等待时间后断开连接

##### Close 和 shutdown 函数

关闭连接的方式通常有两种，分别是 RST 报文关闭和 FIN 报文关闭
进程收到 RST 报文时直接关闭连接，不需要走四次挥手流程，是一种暴力关闭连接的方式

安全关闭连接的方式必须通过四次挥手，由进程调用 `close` 或 `shutdown` 函数发起 FIN 报文

Close 函数完全断开连接，**不仅无法传输数据，而且也不能发送数据**
此时，调用了 close 函数的一方的连接叫做*孤儿连接*，如果你用 `netstat -p` 命令，会发现连接对应的进程名为空

`int shutdown(int sock, int howto)`
Shutdown 函数可控制只关闭一个方向的连接
- SHUT_RD(0)：**关闭读连接**，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了
- SHUT_WR(1)：**关闭写连接**，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被立即发送出去，并发送一个 FIN 报文给对端
- SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，**关闭套接字的读和写两个方向**

### 可靠性传输

#### 超时

TCP 采用*超时/重传机制*来处理报文段的丢失问题，根据往返延时(RTT)动态确定超时时间

TCP 通过定时测量某报文段被发出(即交给 IP)到收到对该报文段的确认之间的时间量得到样本 RTT (SampleRTT)，根据如下公式得到 SampleRTT 均值(称为 EstimatedRTT)
$$EstimatedRTT = (1-\alpha)*EstimatedRTT + \alpha*SampleRTT$$
同时RTT偏差(DevRTT)用于估算SampleRTT 一般会偏离EstimatedRTT的程度
$$DevRTT = （1-\beta）· DevRTT +\beta · | SampleRTT - EstimatedRTT|$$
最终的超时时间为
$$TimeOutInterval = EstinMrtedRTT +4·DevRTT$$
推荐的初始TimeOutInterval值为1秒，在第一次收到报文段前的超时都将加倍TimeOutInterval值以接收到报文段并更新

#### 重传

TCP的可靠数据传输为GBN和SR的混合体
TCP仅启动单个与发送窗口尾部报文段(分组)关联的定时器，超时后仅重传发送窗口尾部的报文段
收到对发送窗口内的报文段的确认时发送窗口尾部收缩至ACK确认号指示的下一报文段，重新启动定时器

产生TCP ACK的建议：
| 接收方的事件                                                     | TCP接收方动作                                                                                               |
| ---------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| 所期望序号的报文段按序到达。所有在期望序号之前的数据都已经被确认 | 延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个报文段在这个时间间隔内没有到达，则发送一个ACK。 |
| 有期望序号的报文段到达。另一个按序报文段等待发送ACK              | 立即发送单个累积ACK，以确认两个按序报文段。                                                                 |
| 比期望序号大的报文段乱序到达。检测出数据流中的间隔               | 立即发送重复的ACK，指明下一个期待字节的序号                                                                 |
| 能部分或完全填充接收数据间隔的报文段到达。                       | 若该报文段起始于间隔的低端，则立即发送ACK。                                                          |

*快速重传*指如果发送方收到同一数据的3个冗余ACK，重传最小序号的段，以避免超时周期太长

#### 流量控制

接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出

接收方在其向发送方的TCP段头部的接收窗口(rwnd)字段“通告”其空闲buffer大小
发送方限制发送未确认字节的个数≤接收方发送过来的rwnd值
此外当接收方rwnd值为0时，发送方继续发送仅1字节的报文段直到确认报文段中告知rwnd非0

### 拥塞控制

网络所需传输的数据超过了网络的处理能力即引发网络拥塞
拥塞的代价：
- 为了达到一个有效输出，网络需要做更多的工作（重传）
- 由于传输速度大幅减慢出现超时引起的没有必要的重传
- 某一分组丢失时，任何用于传输这个分组的上游传输能力都被浪费了

常见的拥塞控制方法包括**端到端拥塞控制**和**网络辅助拥塞控制**
**端到端拥塞控制**中端系统通过对网络行为的观察推断网络拥塞
**网络辅助拥塞控制**中路由器向发送方端系统提供网络拥塞的显式反馈信息

IP层不向端系统提供显式的网络拥塞反馈，因此TCP使用端到端拥塞控制，每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率

#### 感知网络拥塞

某个报文段超时(丢失事件)：拥塞
收到某一报文段的三次冗余ACK：轻微拥塞

#### 限制发送速率

TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量(LastByteRead、rwnd等)组成，运行在发送方的TCP拥塞控制机制跟踪一个额外的变量**拥塞窗口cwnd**(congestion window)
TCP通过以下公式联合进行拥塞控制和流量控制
$LastByteSent - LastByteAcked \leq min\{cwnd, rwnd\}$

#### 速率控制算法

TCP使用ACK来触发(或计时)增大它的拥塞窗口长度，感知到丢包时降低其发送速率

**TCP拥塞控制算法**(TCP congestion control algorithm)使用AIMD(线性增、乘性减少)，包括三个部分
- 慢启动(slow-start, SS)阶段
- 拥塞避免(congestion-avoidance, CA)阶段
- 快速恢复(fast recovery，FR)阶段

1. 连接刚建立时，cwnd通常置为1[[ComputerNetwork.0b.传输层#^mss\|MSS]]
2. 此时为SS阶段，接收到的每个ACK使cwnd增加1MSS，因此每经过1RTT后cwnd*=2，直到发生丢包
3. 丢包时将控制变量ssthresh设为当前cwnd/2，cwnd重新置为1MSS，再次进入SS阶段
4. cwnd增长至ssthresh值后，进入CA阶段，CA阶段中每经过1RTT后cwnd增加1MSS，直到再次丢包
5. 再次丢包后控制变量ssthresh重设为当前cwnd/2，cwnd再次重置为1MSS进入SS阶段
6. 此外当收到3个冗余ACK时进入FR阶段，将控制变量ssthresh重设为当前cwnd/2，cwnd重设为ssthresh+3MSS(来自3个冗余ACK)
	- 之后收到缺失报文段的ACK后直接进入CA阶段
	- 如缺失报文段最终超时，则cwnd重设为1MSS，进入SS阶段

#### 公平性

- 相同RTT下两条TCP连接基本实现平等地共享链路带宽
- 较小RTT能够享用更高吞吐量
- 无拥塞控制的UDP连接会压制TCP流量
- 应用程序可使用多个TCP连接来抢占带宽

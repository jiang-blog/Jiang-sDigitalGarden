---
{"dg-publish":true,"permalink":"/Code/3.ComputerNetwork/ComputerNetwork.0b.传输层/","title":"传输层","noteIcon":""}
---


# 传输层

传输层协议仅运行在主机，网络层提供了主机之间的逻辑通信，而传输层为运行在不同主机上的进程之间提供了逻辑通信(logic communication) 功能。传输层受限于网络层提供的服务(e.g.时延和带宽)的同时，也对网络层服务进行了加强(e.g.可靠的数据传输和加密)
1. 在发送端，运输层将从应用层接收到的报文转换成为运输层报文段（segment）然后将这些报文段传递给网络层
2. 网络层将其封装成网络层分组（即数据报）并向目的地发送。
3. 在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。
4. 运输层则处理接收到的报文段，使该报文段中的数据为应用层使用。

互联网的传输层协议包括TCP和UDP

TCP：
- 字节流
- 可靠数据传输
- 多路复用、解复用
- 流量控制
- 拥塞控制
- 不能提供的服务：时间保证、最小吞吐保证和安全
- 面向连接：要求在客户端进程和服务器进程之间建立连接
TCP的安全性可通过[[Code/3.ComputerNetwork/ComputerNetwork.1.HTTP#SSL\|SSL]]保证

UDP：
- 数据报
- 完成进程间通信
- 多路复用、解复用
- 少量差错检查
- 不做可靠性的工作，因此可提高实时性
- 没有拥塞控制和流量控制，因此应用能够按照设定的速度发送数据

## 传输层数据交互

将主机间交付扩展到进程间交付被称为传输层的**多路复用** (transport-layer multiplexing)与**多路分解**(demultiplexing)

多路复用：从多个socket(套接字)接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部信息加以封装 (该头部信息用于以后的解复用)
多路分解：TCP或UDP实体采用头部信息，将报文段的数据部分交给正确的socket，从而交给正确的进程

>[!note] 端口号
>端口号是一个16比特的数，其大小在0 ~ 65535之间。0 ~ 1023范围的端口号称为**周知端口号**(well-known portnumber)，使用受限制，被保留给诸如HTTP和FTP之类的周知应用层协议来使用。

无连接(UDP)情况下报文仅根据目标主机ip和目标端口号确定交付的目标socket
面向连接情况下报文根据源主机ip，源端口，目标主机ip和目标端口确定目标socket，服务器能够在一个TCP端口上同时支持多个有着不同的源ip或源port的TCP套接字

一台运行Web服务器的主机接收的所有报文段的母单端口都是80，当今的高性能Web服务器通常只使用一个进程，为每个新的客户端连接创建一个具有新连接套接字的新线程。

## UDP

用户数据报协议**UDP**(User Datagram Protocol)仅将应用段报文附加首部信息后传递给网络层，在发送报文段之前，发送方和接收方的运输层实体之间没有握手。
UDP的首部信息包括*源端口号*、*目的端口号*、*长度*和*校验和*，各2字节，共8字节

**校验和**为发送方报文段(视为许多16bit的整数)的加法和(进位回滚)的反码，接收方同样计算报文段的加法和，与校验和相加后理论结果为1111111111111111，存在0则有差错，反之不代表没有差错{ #checksum}


优点：
- 不建立连接，因此延时少
- 不维护连接状态，服务器负载小
- 报文段头部小，传递开销少
- 无拥塞控制和流量控制，可以尽可能快的发送报文段

问题：
- 无拥塞控制容易导致分组溢出，进而引起[[Code/3.ComputerNetwork/ComputerNetwork.0.计算机网络#^PacketLoss\|丢包]]，由无控制的UDP发送方引入的高丢包率将引起TCP发送方大大地减小速率

UDP可通过在应用程序自身中建立可靠性机制来实现可靠数据传输

## 可靠数据传输

**可靠数据传输**RDT(Reliable Data Transfer)为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。
借助于可靠信道，传输数据比特不会损坏（由0变为1，或者相反）或丢失，且所有数据按照发送顺序进行交付。
RDT通过**可靠数据传输协议**实现，可靠数据传输协议的下层协议也许是不可靠的

若下层信道可靠 -> rdt1.0
发送方：
1. 接收上层信息
2. 打包分组
3. 发送给下层信道
接收方：
1. 接收下层信息
2. 解包分组
3. 传递给上层信道

### 比特差错修正

对于下层信道传输中出现的比特受损情况，通过**自动重传请求**(Automatic Repeat reQuest, ARQ)协议解决 -> rdt2.0
发送方：
1. 接收上层信息
2. 打包分组
3. 发送给下层信道
4. 等待接收方反馈
	- ACK：继续发送下一分组
	- NAK：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组
	- 正确
		1. 返回肯定确认**ACK**(positive acknowledgment)
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回否定确认**NAK**(negative acknowledgment)

> [!todo]
>除检验和外具体的分组检验方法

rdt2.0中发送方确信接收方已正确接收当前分组后发送新分组，此种协议称为**停等协议**

对分组编号，在返回ACK中包含该编号可避免ACK在传输过程中受损带来的影响，同时可以用发送一个上次正确接收的分组的ACK来替代NAK -> rdt2.2
发送方：
1. 接收上层信息
2. 打包分组0
3. 发送给下层信道
4. 等待接收方反馈
	- ACK0：继续发送下一分组
	- 乱码/ACK1：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组序号和分组正确性
	- 正确
		1. 返回ACK0
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回ACK1(上一分组的序号)

> [!important]
>以上方法建立在下层信道传递信息时不丢失的基础上

### 数据丢失修正

发送方在一定时间未收到响应后重传分组以避免丢包带来的数据丢失 -> rdt3.0
发送方：
1. 接收上层信息
2. 打包分组0
3. 发送给下层信道
4. 等待接收方反馈
	- ACK0：继续发送下一分组
	- **无响应**/乱码/ACK1：重传当前分组
接收方：
1. 接收下层信息
2. 检验分组序号和分组正确性
	- 正确
		1. 返回ACK0
		2. 解包分组
		3. 传递给上层信道
	- 错误
		1. 返回ACK1(上一分组的序号)

为了实现基于时间的重传机制，需要一个倒计数定时器(countdown timer)，发送方每次发送一个分组（包括第一次分组和重传分组）时便启动一个定时器，定时器中断则重传分组，收到ACK就中止定时器

过早超时（延迟的ACK）也能够正常工作，但是效率较低，发送方至少需要等待这样长的时间：发送方与接收方之间的一个往返时延（可能包括中间路由器的缓冲时延）加上接收方处理一个分组所需的时间。

因为分组序号在0和1之间交替，因此rdt3.0有时被称为**比特交替协议**(alter-nating-bit protocol)

### 性能提升

上述停等方式使得带宽利用率低，严重影响性能。
允许发送方发送多个分组而无须等待确认，从而提高利用率，这种技术称为**流水线技术**

流水线技术需求：
- 增加序号范围，使流水线中的多个分组得以区分
- 发送方和接收方缓存多个分组以重传或排序

所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。两种通用的流水线协议包括**回退N步**(Go-Back-N, GBN)和**选择重传**(Selective Repeat, SR)

停等协议、GBN和SR都属于**滑动窗口协议**(sliding-window protocol)
**发送缓冲区**为内存中存储可发送分组的区域，其大小决定了一次最多可发送的未经确认的分组数(停等为1)
**发送窗口**为发送缓冲区中*已发送但是未经确认的分组*构成的空间
随着缓冲区中分组的发送，发送窗口前部扩展
随着发送缓冲区尾部分组的确认，发送缓冲区向前滑动，直至尾部到达下一个未确认分组，发送窗口尾部收缩
![](https://image.jiang849725768.asia/2022/202212182025758.png)
**接收窗口**=**接收缓冲区**，只有位于接收窗口中的分组才允许接收，其他丢弃
仅在接收到尾部分组后，接收窗口向前滑动，直至尾部到达下一个未接收分组

GBN协议中，接收窗口大小为1分组，因此接收方丢弃所有失序分组。
发送方拥有发送窗口头部分组的定时器，如果出现超时，发送方需依序重传所有发送窗口内的分组。
此协议接收方采用**累积确认**(cumulative acknowledgment)，对失序分组返回上一个正确分组的ACK，所返回的序号为x的ACK表明接收方已正确接收了x及x以前的所有分组
对于GBN协议而言，*发送缓冲区长度必须小于分组序号空间大小*，以避免接收方无法分辨分组为新分组还是重传

SR协议中，接收窗口尺寸大于1分组，接收方缓存接收窗口中的高序号分组直至窗口尾部分组到来，然后将一批连续分组按序向上交付。
发送方为发送窗口中的每个分组保持一个定时器，如果出现超时，发送方仅重传超时的分组
此协议接收方收到分组后发送该分组的ACK，且对于重复接收到的分组依然发送ACK，以防止发送缓冲区阻塞
对于SR协议而言，*发送缓冲区长度必须小于或等于分组序号空间大小的一半*，以避免接收方无法分辨分组为新分组还是重传

GBN协议实现简单，接收方所需缓存空间少，但出错时回退N步代价较大，SR协议与之相反，因此根据不同需求选用不同协议

> [!todo]
> 缓冲区大小的限制因素：流量控制、拥塞控制
> 是否仅需保证发送方缓冲区和接收方缓冲区之和小于分组空间序号大小即可？

## TCP

### 概述

TCP是*面向连接的*，在发送数据前两个进程需要先进行握手(交换控制报文)建立连接(初始化发送方、接收方的状态变量)
TCP连接是*点对点的*，即建立在单个发送方与单个接收方之间
TCP连接是*全双工的*，在同一连接中数据流双向流动

TCP将通过套接字接收的数据引导到连接的发送缓存(send buff)中，依照最大报文段长度(Maximum Segment Size, MSS)分割，加上TCP首部后形成多个TCP报文段，然后下发至网络层
接收端接收到一个报文段后放入连接的接收缓存中，应用程序从此缓存中读取数据流。

> [!note] MSS
> MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度(即所谓的最大传输单元(Maximum Transmission Unit, MTU))来设置。
> TCP/IP首部长度通常为40字节。以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。
{ #mss}

#### 报文格式

TCP首部信息：
- **源端口号**(16bit)
- **目标端口号**(16bit)
- **序号**(32bit) - 报文段首字节在字节流中的编号
- **确认号**(32bit) - 期望从另一方收到的下一个字节的序号
- **接收窗口**(16bit) - 愿意接收的字节数量
- **首部长度/数据偏移**(4bit) - 以32bit的字为单位的TCP首部长度
- 保留字段(6bit) - 保留为今后使用，不使用
- **标志字段**(6bit)
	- **ACK** - 指示确认号字段值的有效性
	- **RST**、**SYN**和**FIN** - 用于连接建立和拆除
	- URG - 紧急数据，不使用
	- PSH - 马上推出(立即上交)数据，不使用
- **校验和**(16bit)
- 紧急数据指针(16bit) - 不使用
- **选项**(不定)
- **填充** - 使整个首部长度是32bit的字的整数倍

TCP把数据看成一个无结构的、有序的字节流，其隐式地对数据流中的每一个字节编号，**序号**是当前报文段首字节的字节流编号，**确认号**为希望对方主机发送的下一报文段所含数据的首字节的编号
序号到达2^32-1后重新从0开始
一条TCP连接的双方均可随机地选择初始序号，这样做可以减少两台主机的新建连接受到仍在网络中存在的过期连接的报文段的影响

### TCP连接管理

#### 建立连接

在正式交换数据之前，发送方和接收方握手建立通信关系

两次握手导致*半连接*和*老数据被当作新数据接收*
![|600](https://image.jiang849725768.asia/2022/202212191650984.png)

三次握手：
1. 客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段，该报文段中不包含应用层数据，首部字段中SYN为1，同时客户端选择确定其初始序号(client_isn)。这个特殊报文段被称为**SYN报文段**
2. 服务器接收SYN报文段，为TCP连接分配TCP缓存和变量，向该客户TCP发送允许连接的报文段，该报文段中也不包含应用层数据，首部字段中SYN为1，确认号为client_isn+1，同时服务端选择确定其初始序号(server_isn)，该报文段称为**SYNACK报文段**
3. 客户端接收SYNACK报文段，为TCP连接分配TCP缓存和变量，首部字段中SYN为0(连接已建立)，确认号为server_isn+1，该报文段可在主体中携带应用层数据

SYN 报文是特殊的 TCP 报文，虽然 SYN 报文不携带用户数据，但**TCP 将 SYN 报文视为 1 字节的数据**，当对方收到了 SYN 报文后，在回复 ACK 报文时，就需要将 ACK 报文中的确认号设置为 SYN 的序列号 + 1

#### 关闭连接

客户端或服务端都能请求关闭连接，请求方发送首部字段FIN为1的FIN报文段，等待对方ACK，收到ACK后等待对方的FIN报文段，收到报文段后返回确认(此时若对方接收到确认则对方确定连接正式关闭，释放所有资源)，继续等待一段时间后确定连接正式关闭，请求方释放所有资源

### 可靠性传输

#### 超时时间确定

TCP采用超时/重传机制来处理报文段的丢失问题，根据往返延时(RTT)动态确定超时时间。
TCP通过定时测量某报文段被发出(即交给IP)到收到对该报文段的确认之间的时间量得到样本RTT (SampleRTT)，根据如下公式得到SampleRTT均值(称为EstimatedRTT)
$EstimatedRTT = (1-\alpha)*EstimatedRTT + \alpha*SampleRTT$
同时RTT偏差(DevRTT)用于估算SampleRTT 一般会偏离EstimatedRTT的程度
$DevRTT = （1-\beta）· DevRTT +\beta · | SampleRTT - EstimatedRTT|$
最终的超时时间为
$TimeOutInterval = EstinMrtedRTT +4·DevRTT$
推荐的初始TimeOutInterval值为1秒，在第一次收到报文段前的超时都将加倍TimeOutInterval值以接收到报文段并更新

#### 重传

TCP的可靠数据传输为GBN和SR的混合体
TCP仅启动单个与发送窗口尾部报文段(分组)关联的定时器，超时后仅重传发送窗口尾部的报文段
收到对发送窗口内的报文段的确认时发送窗口尾部收缩至ACK确认号指示的下一报文段，重新启动定时器

产生TCP ACK的建议：
| 接收方的事件                                                     | TCP接收方动作                                                                                               |
| ---------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| 所期望序号的报文段按序到达。所有在期望序号之前的数据都已经被确认 | 延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个报文段在这个时间间隔内没有到达，则发送一个ACK。 |
| 有期望序号的报文段到达。另一个按序报文段等待发送ACK              | 立即发送单个累积ACK，以确认两个按序报文段。                                                                 |
| 比期望序号大的报文段乱序到达。检测出数据流中的间隔               | 立即发送重复的ACK，指明下一个期待字节的序号                                                                 |
| 能部分或完全填充接收数据间隔的报文段到达。                       | 若该报文段起始于间隔的低端，则立即发送ACK。                                                          |

**快速重传**指如果发送方收到同一数据的3个冗余ACK，重传最小序号的段，以避免超时周期太长

#### 流量控制

接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出

接收方在其向发送方的TCP段头部的接收窗口(rwnd)字段“通告”其空闲buffer大小
发送方限制发送未确认字节的个数≤接收方发送过来的rwnd值
此外当接收方rwnd值为0时，发送方继续发送仅1字节的报文段直到确认报文段中告知rwnd非0

### 拥塞控制

网络所需传输的数据超过了网络的处理能力即引发网络拥塞
拥塞的代价：
- 为了达到一个有效输出，网络需要做更多的工作（重传）
- 由于传输速度大幅减慢出现超时引起的没有必要的重传
- 某一分组丢失时，任何用于传输这个分组的上游传输能力都被浪费了

常见的拥塞控制方法包括**端到端拥塞控制**和**网络辅助拥塞控制**
**端到端拥塞控制**中端系统通过对网络行为的观察推断网络拥塞
**网络辅助拥塞控制**中路由器向发送方端系统提供网络拥塞的显式反馈信息

IP层不向端系统提供显式的网络拥塞反馈，因此TCP使用端到端拥塞控制，每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率

#### 感知网络拥塞

某个报文段超时(丢失事件)：拥塞
收到某一报文段的三次冗余ACK：轻微拥塞

#### 限制发送速率

TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量(LastByteRead、rwnd等)组成，运行在发送方的TCP拥塞控制机制跟踪一个额外的变量**拥塞窗口cwnd**(congestion window)
TCP通过以下公式联合进行拥塞控制和流量控制
$LastByteSent - LastByteAcked \leq min\{cwnd, rwnd\}$

#### 速率控制算法

TCP使用ACK来触发(或计时)增大它的拥塞窗口长度，感知到丢包时降低其发送速率

**TCP拥塞控制算法**(TCP congestion control algorithm)使用AIMD(线性增、乘性减少)，包括三个部分
- 慢启动(slow-start, SS)阶段
- 拥塞避免(congestion-avoidance, CA)阶段
- 快速恢复(fast recovery，FR)阶段

1. 连接刚建立时，cwnd通常置为1[[Code/3.ComputerNetwork/ComputerNetwork.0b.传输层#^mss\|MSS]]
2. 此时为SS阶段，接收到的每个ACK使cwnd增加1MSS，因此每经过1RTT后cwnd*=2，直到发生丢包
3. 丢包时将控制变量ssthresh设为当前cwnd/2，cwnd重新置为1MSS，再次进入SS阶段
4. cwnd增长至ssthresh值后，进入CA阶段，CA阶段中每经过1RTT后cwnd增加1MSS，直到再次丢包
5. 再次丢包后控制变量ssthresh重设为当前cwnd/2，cwnd再次重置为1MSS进入SS阶段
6. 此外当收到3个冗余ACK时进入FR阶段，将控制变量ssthresh重设为当前cwnd/2，cwnd重设为ssthresh+3MSS(来自3个冗余ACK)
	- 之后收到缺失报文段的ACK后直接进入CA阶段
	- 如缺失报文段最终超时，则cwnd重设为1MSS，进入SS阶段

#### 公平性

- 相同RTT下两条TCP连接基本实现平等地共享链路带宽
- 较小RTT能够享用更高吞吐量
- 无拥塞控制的UDP连接会压制TCP流量
- 应用程序可使用多个TCP连接来抢占带宽

---
{"dg-publish":true,"permalink":"/Code/4.OS/OS.0b.内存管理/","title":"内存管理","noteIcon":""}
---


# 内存管理

## 虚拟内存

操作系统提供一种机制，**将不同进程的虚拟地址和内存中不同的物理地址进行映射**，以避免进程同时运行时写入内存的冲突

CPU 通过**内存管理单元**(MMU)将进程持有的虚拟地址按映射关系转变成物理地址，然后再通过物理地址访问内存

### 内存分段

程序由若干个逻辑分段如代码分段、数据分段、栈段、堆段组成，不同的段有不同的属性，所以就用**分段(*Segmentation*)** 的形式把这些段分离出来

>![a9ed979e2ed8414f9828767592aadc21.png (1382×1004) (xiaolincoding.com)](https://cdn.xiaolincoding.com//mysql/other/a9ed979e2ed8414f9828767592aadc21.png)

分段机制下的虚拟地址由**段选择因子**和**段内偏移量**两部分组成
- **段选择因子**保存在段寄存器里，包括用作段表的索引的**段号**，**段表**里面保存的**段基地址、段界限和特权等级**等
- 虚拟地址中的**段内偏移量**位于 0 和段界限之间，段内偏移量合法时将段内偏移量加上段基地址即可得到物理内存地址

分段机制会把程序的虚拟地址分成 4 个段(栈，堆，数据，代码)，每个段在段表中有一个项，包含该段的段基地址

内存分段存在**内存碎片**和**内存交换效率低**两大问题

多个不连续的小物理内存导致在空闲内存足够的情况下新的程序无法被装载，进而导致**外部内存碎片**

通过**内存交换**，可将小物理内存写入硬盘，再次读入时紧密排列，进而空缺出连续空闲内存空间

但如果内存交换的时候，交换的是一个占内存空间很大的程序，会严重影响性能

### 内存分页

内存分页用于解决内存分段存在的问题，**把整个虚拟和物理内存空间分成固定尺寸的页(*Page*)**
在 Linux 下，每一页的大小为 `4KB`

虚拟地址与物理地址之间通过**页表**来映射，页表存储在内存中，依然由**内存管理单元 (*MMU*)** 将虚拟内存地址转换成物理地址
当进程访问的虚拟地址在页表中查不到时，系统产生一个**缺页异常**，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行
操作系统负责维护页表，它为**每个进程提供了一个独立的页表，即一个独立的虚拟地址空间**

> ![](https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png)

分页机制下的虚拟地址由**页号**和**页内偏移量**两部分组成
- **页号**作为页表的索引，页表包含物理页每页**所在物理内存的基地址**
- **页内偏移量**加上物理内存的基地址形成了实际物理内存地址

内存分页机制分配内存的最小单位是一页，页与页之间紧密排列，所以不会有外部内存碎片，但页内可能会出现内存浪费，所以内存分页机制会有**内部内存碎片**

内存空间不够时，操作系统**换出**其他正在运行的进程中**最近没被使用**的内存页面至硬盘，需要的时候再重新**换入**，仅操作少数页，内存交换效率高
同时加载程序时可延迟加载内存页至物理内存，仅在实际使用时进行加载

#### 多级页表

简单分页下由于每个进程需要有虚拟的独属完整内存空间，也即有自己的页表，因此需要庞大的内存空间存储所有进程的页表

> 在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB(2^12)，那么就需要大约 100 万 (2^20) 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 `4MB` 的内存来存储页表
> `100` 个进程的话，就需要 `400MB` 的内存来存储页表

**多级页表**中一级页表覆盖完整的虚拟地址空间，但其中仅存储一级页号和二级页表地址，二级表中存储实际物理页号
大多数程序使用空间远小于实际物理内存，因此可以延迟到实际访问时真正创建二级页表，进而节约内存空间
> ![19296e249b2240c29f9c52be70f611d5.png (1686×1146) (xiaolincoding.com)](https://cdn.xiaolincoding.com//mysql/other/19296e249b2240c29f9c52be70f611d5.png)

对于 64 位系统，采用**四级目录**来进一步节省空间：
- 全局页目录项 PGD(_Page Global Directory_)
- 上层页目录项 PUD(_Page Upper Directory_)
- 中间页目录项 PMD(_Page Middle Directory_)
- 页表项 PTE(_Page Table Entry_)

#### TLB

根据**局部性原理**，在一段时间内，程序倾向于访问同一块或相邻的内存地址

因此在 CPU 中存在一个存放程序最常访问的页表项的缓存 **TLB**，又称页表缓存、转址旁路缓存、快表等

TLB 同样由 CPU 通过 MMU 访问

> [! note] 局部性原理
> 局部性原理指的是，在计算机程序运行过程中，访问内存的数据和指令往往呈现出一定的局部性特征，即在一段时间内，程序倾向于访问同一块或相邻的内存地址。局部性原理主要包括以下三种类型：
> - 时间局部性：指程序在某个时间点访问某个内存地址时，很可能在不久的将来再次访问该地址
> - 空间局部性：指程序在访问某个内存地址时，很可能在不久的将来访问该地址相邻的内存地址
> - 块局部性：指程序在访问某个内存地址时，很可能在不久的将来访问该地址所在的内存块中的其他地址

#### 写时复制

父子进程通过页表的复制共享一片物理内存，当父进程或者子进程向这个内存发起写操作时，CPU 就会触发**写保护中断**，然后操作系统会在「写保护中断处理函数」里进行**相应物理内存的复制**，并重新设置其内存映射关系，将父子进程的内存读写权限设置为**可读写**，最后才会对复制出的内存进行写操作，这个过程被称为**写时复制(_Copy On Write_)**

### 段页式内存管理

**段页式内存管理**为内存分段和内存分页的组合

实现方式：先将程序划分为多个有逻辑意义的段，再把每个段划分为多个固定大小的页

该机制下地址结构由**段号、段内页号和页内位移**三部分组成

> ![8904fb89ae0c49c4b0f2f7b5a0a7b099.png (1452×699) (xiaolincoding.com)](https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)

段页式地址变换中经过三次内存访问得到物理地址：
1. 访问段表，得到页表起始地址
2. 访问页表，得到物理页号
3. 将物理页号与页内位移组合，得到物理地址

## Linux内存管理

### Intel CPU

intel 的 80386 CPU**在由段式内存管理所映射而成的地址上再加上一层地址映射进行页式内存管理**
段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址
> ![bc0aaaf379fc4bc8882efd94b9052b64.png (1050×138) (xiaolincoding.com)](https://cdn.xiaolincoding.com//mysql/other/bc0aaaf379fc4bc8882efd94b9052b64.png)

### Linux

Linux 内存主要采用页式内存管理，但由于依托于 Intel 的 CPU，同时也涉及了段机制

**Linux 中每个段都是从 0 地址开始的整个 4GB 虚拟空间(32 位)**，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间(虚拟地址)，这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护

Linux 操作系统中虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同

> ![3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.png (1097×422) (xiaolincoding.com)](https://cdn.xiaolincoding.com//mysql/other/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.png)

进程在用户态时，只能访问用户空间内存，只有进入内核态后，才可以访问内核空间的内存

**每个虚拟内存中的内核地址关联的都是相同的物理内存**
> ![48403193b7354e618bf336892886bcff.png (950×426) (xiaolincoding.com)](https://cdn.xiaolincoding.com//mysql/other/48403193b7354e618bf336892886bcff.png)

对于一个完整的段式内存，32 位系统又将用户空间内存从低到高分为 7 种内存段
- 保留区，不可访问，在大多数的系统里较小数值的地址不是一个合法地址
- 代码段，包括二进制可执行代码
- 数据段，包括已初始化的静态常量和全局变量
- BSS 段，包括未初始化的静态变量和全局变量
- 堆段，包括动态分配的内存，从低地址开始向上增长
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长(跟硬件和内核版本有关)
- 栈段，包括局部变量和函数调用的上下文等(栈的大小是固定的，一般是 8 MB)

> ![32位虚拟内存布局.png (1210×976) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

## 内存分配

### malloc

malloc 是 C 语言库中用于动态分配内存的函数，其申请内存时存在两种向操作系统申请堆内存的方式
- 通过 `brk()` 从堆分配内存
  - 将指向堆顶的指针向高地址移动，获得新的内存空间
  - free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用
  - 缺点：缓存导致堆内产生众多不可用小碎片
- 通过 `mmap()` 系统调用从文件映射分配内存
  - 以匿名映射的方式从文件映射区分配的匿名内存
  - free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放
  - 缺点：每次都会发生运行态的切换，第一次访问分配的虚拟地址时会发生缺页中断(mmap 没有缓存，分配的内存每次释放时都会归还给操作系统)

malloc 分配的是虚拟内存而非物理内存

malloc 分配内存时会多申请 16 byte 用于保存该内存块的描述信息(e.g. 内存块的大小)

### 内存回收

当 CPU 访问没有映射到物理内存的虚拟内存时，就会产生**缺页中断**，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler (缺页中断函数)处理

如果有空闲物理内存直接分配并建立映射，没有则触发**内存回收**
- **后台内存回收**(kswapd)：唤醒 kswapd 内核线程异步回收内存，不会阻塞进程的执行
- **直接内存回收**(direct reclaim)：后台异步回收跟不上进程内存申请的速度时进行直接内存回收，阻塞进程执行同步回收内存

主要有两类内存可以被回收：
- **文件页**(File-backed Page)：内核缓存的磁盘数据(Buffer)和内核缓存的文件数据(Cache)
  - 对于文件页，回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存
- **匿名页**(Anonymous Page)：堆、栈数据等，这部分内存没有真实文件载体，且很可能还要再次被访问，所以不能直接释放内存
  - 通过 Linux 的 Swap 机制回收，Swap 把不常访问的内存先写到磁盘中，然后释放内存空间，再次访问这些内存时重新从磁盘读入

文件页和匿名页的回收都是基于 LRU 算法(优先回收不常访问)，维护 active 和 inactive 两个双向链表

回收内存时脏页写回磁盘和 swap 换入磁盘都会发生磁盘 IO，产生性能开销

> [!todo] 性能优化方案
> [回收内存带来的性能影响](https://xiaolincoding.com/os/3_memory/mem_reclaim.html#%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D)
> 调整文件页和匿名页的回收倾向
> 尽早触发 kswapd 内核线程异步回收内存
> NUMA 架构下的内存回收策略

#### SWAP

SWAP 机制将内存数据换出磁盘，又从磁盘中恢复数据到内存
SWAP 会在内存不足和内存闲置的场景下触发：
- **内存不足**：当系统需要的内存超过了可用的物理内存时，内核会使用直接内存回收将内存中不常使用的内存页交换到磁盘上为当前进程让出内存
- **内存闲置**：应用程序在启动阶段使用的大量内存之后往往都不会使用，内核通过后台运行的守护进程 kSwapd 将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间

Linux 提供了Swap 分区（Swap Partition）和 Swap 文件（Swapfile）两种方法启用 Swap
- Swap 分区是硬盘上的独立区域，该区域只会用于交换分区，其他的文件不能存储在该区域上，可以使用 `swapon -s` 命令查看当前系统上的交换分区
- Swap 文件是文件系统中的特殊文件，与文件系统中的其他文件没有太大区别

### 内存溢出

直接内存回收后仍无法满足内存申请时触发 **OOM(Out of Memory)** 机制

OOM Killer 会根据算法**循环杀死一个占用物理内存较高的进程**以便释放内存资源，直到释放足够的内存位置

Linux 内核使用 `oom_badness()` 函数扫描系统中可以被杀掉的进程并对每个进程打分，首先杀掉得分最高的进程
```C
// points 代表打分的结果
// process_pages 代表进程已经使用的物理内存页面数
// oom_score_adj 代表 OOM 校准值
// totalpages 代表系统总的可用页面数
points = process_pages + oom_score_adj*totalpages/1000
```
oom_score_adj 默认为 0，可修改该值以减小进程被杀的可能

> [!note] 在 32 位/64 位操作系统环境下，申请的虚拟内存超过物理内存后会怎么样？
> -   在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败
> -   在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存
> - 如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：
> -   如果没有开启 Swap 机制，程序会直接 OOM
> -   如果有开启 Swap 机制，程序可以正常运行

## 缓存


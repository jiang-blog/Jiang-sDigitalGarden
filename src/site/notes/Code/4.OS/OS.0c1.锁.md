---
{"dg-publish":true,"permalink":"/Code/4.OS/OS.0c1.锁/","title":"锁","noteIcon":""}
---


# 锁

## 锁类型

### 悲观锁&乐观锁

*悲观锁*认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁
*乐观锁*假定冲突的概率很低，先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作

乐观锁也叫*无锁编程*，全程不加锁

### 互斥锁&自旋锁

当已经有一个线程加锁后，其他线程加锁则就会失败

*互斥锁*加锁失败后，线程会释放 CPU 给其他线程
*自旋锁*加锁失败后，线程会占据 CPU 忙等待直到拿到锁

互斥锁是一种独占锁，加锁失败时由操作系统内核实现阻塞，

互斥锁存在两次线程上下文切换，因此当加锁执行的代码执行时间较短时，应选用自旋锁减小开销

自旋锁通过 CPU 提供的 CAS 函数完成加锁
1. 查看锁的状态
2. 如果锁处于空闲状态，将锁设置为当前线程持有

CAS 函数将两个步骤合并成一条硬件级指令，形成**原子指令**，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行
CAS 本身为乐观锁，但自旋锁为借助 CAS 实现的悲观锁

在单核 CPU 上使用自旋锁需要抢占式的调度器(即不断通过时钟中断一个线程，运行其他线程)，因为一个自旋的线程永远不会放弃 CPU

### 读写锁

当写锁没有被线程持有时，多个线程能够并发地持有读锁
一旦写锁被线程持有后，其他线程对于读锁和写锁的获取都会阻塞

**读写锁适用于读多写少的场景**

读写锁又可分为*读优先锁*和*写优先锁*
- 读优先锁在读锁被持有时阻塞写锁，同时允许新读锁的获取
- 写优先锁在存在被阻塞的写锁时，不允许其他线程获取新读锁

读优先锁和写优先锁都可能会产生饥饿问题，因此需要*公平读写锁*
公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁

## 死锁

死锁只有**同时满足**以下四个条件才会发生：
- 互斥 - 多个线程不能同时使用同一个资源
- 持有并等待 - 线程在等待时不释放自己已持有的资源
- 不可剥夺 - 当资源已被线程持有时，在该线程使用完之前不能被其他线程获取
- 环路等待 - 两个线程获取资源的顺序构成了环形链

### 避免死锁

避免死锁问题只需要破环其中一个条件，最常见的并且可行的就是**使用资源有序分配法来破环环路等待条件**

资源有序分配法让线程尝试获取资源的顺序相同，例如所有线程必须先获取互斥锁 A，然后获取互斥锁B

#### 银行家算法

当一个进程申请使用资源的时候，银行家算法通过先 **试探** 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待

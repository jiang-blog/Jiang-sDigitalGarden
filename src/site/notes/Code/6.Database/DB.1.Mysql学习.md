---
{"dg-publish":true,"permalink":"/Code/6.Database/DB.1.Mysql学习/","title":"Mysql 学习","noteIcon":""}
---


# Mysql 学习

MySQL是一个传统的RDBM数据库，也就是关系型数据库，广泛应用于OLTP场景

**OLTP**(联机事务处理)是传统的关系型数据库的主要应用，用于基本的日常交易处理，例如银行的交易记录
**OLAP**(联机分析处理)是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并提供直观和易于理解的查询结果。最常见的应用是复杂的动态报告系统
一般来说，OLTP用于日常处理，OLAP用于数据分析

## 语法

### 数据类型

MySQL 支持所有标准 SQL 数值数据类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型

> [MySQL 数据类型 | 菜鸟教程 (runoob.com)](https://www.runoob.com/mysql/mysql-data-types.html)

#### Varchar & char

Char 是一种固定长度的类型，varchar 则是一种可变长度的类型

Varchar 不是越大越好，在内存加载时每次按最大空间分配，varchar 占用空间大

Varchar 会在行记录头部额外用字节存储长度信息

Varchar(n)中 n 在 V5.0以前代表*最多存储字节数*，之后代表**最多存储字符数**

#### Int

在 int(11)中的11仅代表显示长度为11，不影响存储空间(**将被废弃**)

#### BLOB&TEXT

BLOB 是一个二进制大对象，可以容纳可变数量的数据
有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，区别在于可容纳存储范围不同
TEXT 为非二进制文本数据，同样有4种类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT，与 BLOB 相对应

### SELECT

子句顺序：
| 子句     | 说明               | 是否必须使用           |
| -------- | ------------------ | ---------------------- |
| SELECT   | 要返回的列或表达式 | 是                     |
| FROM     | 从中检索数据的表   | 仅在从表选择数据时使用 |
| WHERE    | 行级过滤           | 否                     |
| GROUP BY | 分组说明           | 仅在按组计算聚集时使用 |
| HAVING   | 组级过滤           | 否                     |
| ORDER BY | 输出排序顺序       | 否                     |
| LIMIT    | 要检索的行数       | 否                     |

### NULL

在匹配过滤和不匹配过滤中都不返回 NULL 值

COUNT(column)对特定列中具有值的行进行计数，忽略 NULL 值

### 大小写

Mysql 中查询数据时是否区分大小写取决于以下几个因素：
- 数据库表的字符集和排序规则
  - 如果字符集是二进制的，如 binary、varbinary 等，那么查询时会区分大小写
  - 如果排序规则是二进制的，如 utf8_bin、latin1_bin 等，那么查询时也会区分大小写
- 数据库表的存储引擎
  - 如果存储引擎是 MyISAM 或 InnoDB，那么查询时会根据字符集和排序规则来判断是否区分大小写
  - 如果存储引擎是 MEMORY 或 CSV，那么查询时不会区分大小写
- 操作系统的文件系统。如果数据库表是以文件形式存储在操作系统中，那么查询时会受到文件系统是否区分大小写的影响
  - 在 Linux 系统中，文件名是区分大小写的，所以查询时也会区分大小写
  - 在 Windows 系统中，文件名是不区分大小写的，所以查询时也不会区分大小写

### 函数

> [MySQL 函数 | 菜鸟教程 (runoob.com)](https://www.runoob.com/mysql/mysql-functions.html)

### 约束

MySQL 唯一约束(Unique Key)要求该列唯一，允许为空，但只能出现一个空值

MySQL 非空约束(NOT NULL)通过 `CREATE TABLE` 或 `ALTER TABLE` 语句中在某个字段的定义后加上关键字 `NOT NULL` 作为限定词，来约束该列的取值不能为空

### 其他

- 应该总是使用4位数字的年份
- 在仅需要日期时始终使用 Date()
- 使用 ORDER BY 排序数据，不依赖 GROUP BY 排序数据
- 如果想从表中删除所有行，不要使用 DELETE，可使用 TRUNCATE TABLE 语句，它完成相同的工作，但速度更快(TRUNCATE 实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据)
- 用 SHOW processlist 可以查看用户正在运行的所有线程以及对应执行的 sql 命令

## 基础知识

### 操作分类

> [SQL |DDL、DQL、DML、DCL 和 TCL 命令 - GeeksforGeeks](https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/)

#### DDL

*数据定义 - Data Definition Language*，用于**创建、修改和删除数据库结构**
- CREATE：用于创建数据库或其对象(如表、索引、函数、视图、存储过程和触发器)
- DROP：用于从数据库中删除对象
- ALTER：用于改变数据库的结构
- TRUNCATE：用于从表中删除所有记录，包括为删除的记录分配的所有空间
- COMMENT：用于向数据字典添加注释
- RENAME：用于重命名数据库中存在的对象

#### DQL

*数据查询 - Data Query Language*，用于**查询架构对象中的数据**
- SELECT：用于从数据库中检索数据

#### DML

*数据操作 - Data Manipulation Language*，为用户提供**添加、删除、更新数据**的能力
- INSERT：用于将数据插入表中
- UPDATE：用于更新表中的现有数据
- DELETE：用于从数据库表中删除记录
- LOCK：表并发控制
- CALL：调用一个 PL/SQL 或 JAVA 子程序
- EXPLAIN PLAN：描述数据的访问路径

#### DCL

*数据控制 - Data Control Language*，主要**处理数据库系统的权限**
- GRANT：此命令授予用户访问数据库的权限
- REVOKE：此命令撤消使用 GRANT 命令授予的用户访问权限

#### TCL

*事务控制 - Transaction Control Language*，主要**控制数据库中的事务**
事务将一组任务分组到单个执行单元中，每个事务都以特定任务开始，并在组中的所有任务成功完成时结束，如果任何任务失败，事务将失败
- BEGIN：开启事务
- COMMIT：提交事务
- ROLLBACK：在发生任何错误的情况下回滚事务
- SAVEPOINT：在事务中设置一个保存点
- SET TRANSACTION： 指定事务的特征

### 三范式

*第一范式*：数据库表的每一字段都是不可分割的基本数据项
在任何一个关系数据库中，1NF 是对关系模式的基本要求，不满足1NF 的数据库就不是关系数据库

*第二范式(依赖性)*：数据库表中的每个实例或行必须可以被唯一的区分
2NF 建立在1NF 之上，要求实体的属性完全依赖于主关键字，不能仅依赖部分主关键字

*第三范式(唯一性)*： 一个数据库表中不包含已在其它表中包含的非主关键字信息
3NF 建立在2NF 之上，非主键字段不能相互依赖，任何非主属性不依赖于其它非主属性

*逆范式*: 通过增加冗余或重复的数据来提高数据库的读性能

### 主键&辅助键&外键

> [主键和外键约束 - SQL Server | Microsoft Learn](https://learn.microsoft.com/zh-cn/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16)

#### 主键

*主键*(PRIMARY KEY)是用于唯一标识数据库中每条记录的字段，不能包含NULL值
选取主键的一个基本原则：**不使用任何业务相关的字段作为主键**

**一个表只能有一个主键约束**，该约束可以包含一个或多个字段，构成主键的多个字段被统一称为*联合主键*

主键设置：
- CREATE创建库时指定
- 通过ALTER添加

主键设计：
- 自增主键设计：数据库会在插入数据时自动为每一条记录分配一个自增整数
  - 用 BIGINT 而非 INT做主键
  - 当达到自增整型类型的上限值时，再次自增插入，MySQL 数据库会报重复错误
  - MySQL 8.0 版本前自增值存在回溯现象，不建议使用
  - 自增值做主键，只能在当前实例中保证唯一，**不能保证全局唯一**
- UUID主键设计：使用一种全局唯一的字符串作为主键
- 业务自定义生成主键：在随机主键基础上结合业务信息生成主键

#### 辅助键

*辅助键*显示每条记录唯一的辅助值，它可用于标识记录，并且通常被索引，它也被称为**备用键**，**一个表可以有多个辅助键**

#### 外键

*外键* (FOREIGN KEY) 是用于在两个表中的数据之间建立和加强链接的一列或多列的组合，约束两个表中数据的**一致性和完整性**
相关联字段中主键所在的表就是主表(父表)，外键所在的表就是从表(子表)，**默认情况下子表的记录相关数据删除后，主表才能删除记录**

## 事务

> [深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kismetv/p/10331633.html)

事务(Transaction)是访问和更新数据库的程序执行单元，事务中可能包含一个或多个sql语句，**这些语句要么都执行，要么都不执行**

```mysql
start transaction; -- begin; -- 事务开始
... # n条sql语句
commit; -- 提交事务，将结果写入数据库
```

如果sql语句执行出现问题，事务调用rollback回滚所有已经执行成功的sql语句

Mysql 中默认采用 *autocommit* 模式，如果没有`start transaction`显式开启一个事务，则**每个sql语句都被当作一个事务执行**
如关闭autocommit，则所有sql语句都在同一事务中，直到执行commit或rollback结束该事务并开启一个新事务

此外存在一些特殊命令，在事务中执行这些命令时会马上强制执行 commit 提交事务，如 DDL 语句(create table/drop table/alter table)和lock tables 语句等等

### ACID

ACID是原子性、一致性、隔离性和持久性的缩写

#### 原子性

**一个事务只有执行成功和失败回滚两种状态，没有中间态**

当事务对数据库进行修改时，InnoDB会生成对应的**undo log**，记录sql执行的相关信息
当发生回滚时InnoDB根据undo log内容做相反工作

#### 持久性

**事务一旦提交，它对数据库的改变就应该是永久性的**

使用 redo log 保证 buffer pool 中的数据不随 Mysql 非正常停止而消失

#### 隔离性

**事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰**

通过锁机制和MVCC保证

#### 一致性

**事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态**

数据库的完整性约束包括实体完整性(如行的主键存在且唯一)、列完整性(如字段的类型、大小、长度要符合要求)、外键约束、用户自定义完整性(如转账前后，两个账户余额的和应该不变)等

### 并发安全

#### 并发问题

Mysql支持多个客户端连接，在同时处理多个事务的时候会出现并发问题，按照严重性从高到低分别为：
- **幻读**：在一个事务内前后查询的符合某条件的记录数量不相同
- **不可重复读**：在一个事务内前后读取的同一个数据不相同
- **脏读**：事务读取了另一个事务修改过但未提交的数据

#### SQL隔离级别

SQL标准针对并发事务执行提出了四种隔离级别，隔离级别越高，开销越大，出现的问题越少，从低到高分别为：
- **读未提交**：指一个事务还没提交时，它做的变更就能被其他事务看到
  - 直接读取最新数据
  - 可能发生脏读、不可重复读和幻读
- **读已提交**：指一个事务提交之后，它做的变更才能被其他事务看到
  - 在每个语句执行前创建 Read View(数据快照)
  - 可能发生不可重复读和幻读
- **可重复读**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的
  - 在事务启动时创建 Read View(数据快照)
  - 可能发生幻读
- **串行化**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行
  - 加读写锁
  - 三种问题都不会发生

> [!Note] Read View
> Read View 中包含四个重要字段：
> ![readview结构.drawio.png (900×437) (xiaolincoding.com)|600](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png){ #readview}


> [!attention] 事务启动时机
> `begin;/start transaction;`：事务开始未启动，事务启动于下一条增删查改语句
> `start transaction with consistent snapshot;`：事务立刻启动

#### MVCC

MVCC即**多版本并发控制**，通过比较读取行记录的trx_id与Read View确认记录版本，**通过版本链控制并发事务访问**

事务更新行记录后 Mysql 记录相应的 undo log，通过 [[Code/6.Database/DB.1c.InnoDB数据存储#隐藏字段\|行记录隐藏字段]]中的 roll_pointer 串联 undo log 形成版本链，并将最新记录的 trx_id 设为当前事务 id

- `trx_id < min_trx_id:` 该版本记录创建/更新于当前事务启动前，可见
- `trx_id >= max_trx_id`: 该版本记录可能创建/更新于当前事务启动后，不可见
- `min_trx_id <= trx_id < max_trx_id`
  - `trx_id` 在 `m_ids` 中：该版本记录可能创建/更新于当前事务启动后，不可见
  - `trx_id` 不在 `m_ids` 中：该版本记录创建/更新于当前事务启动前，可见

只有在聚簇索引记录中才有 trx_id 和 roll_pointer，如果某个查询语句使用二级索引来查询，要使用下面的方式判断可见性：
二级索引树索引页的 [[Code/6.Database/DB.1c.InnoDB数据存储#页结构\|Page Header]] 部分存在 `PAGE_MAX_TRX_ID` 属性，记录修改该索引页的最大事务 id
执行增删改操作时，如果执行该操作的事物的事务 id 大于 `PAGE_MAX_TRX_ID`，则将 `PAGE_MAX_TRX_ID` 设置为执行操作的事务 id

当 SELECT 语句访问某个二级索引记录时，如果 readView 的 `min_trx_id > PAGE_MAX_TRX_ID`，说明该页面中的所有记录对该 ReadView 可见
否则需要执行回表判断，利用二级索引记录中的主键值进行回表操作，得到对应的聚簇索引记录后再按照聚簇索引的方式判断该可见性

#### InnoDB隔离

**InnoDB 引擎的默认隔离级别为可重复读**
MySQL 里除了普通select是**快照读**，其他都是**当前读**，比如 update、insert、delete以及select … for update 等语句

InnoDB通过MVCC解决快照读下的幻读，通过[[Code/6.Database/DB.1.Mysql学习#行级加锁\|行级加锁]]解决当前读情况下的幻读，两种方法很大程度上避免了幻读，但是[**没能完全解决幻读**](https://xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97)
>避免特殊场景下发生幻读的现象的方法就是**尽量在开启事务之后，马上执行 `select … for update` 这类当前读的语句**，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录

## 其他

### 伪列

伪列是指**一些具有特殊含义的列名**，它们并不是表中实际存在的列，但可以在 SQL 查询语句中使用
伪列的行为与表中的列相同，但并未存储具体数值，因此**伪列只具备读属性**

常见的伪列：
- `ROWNUM`：用于返回每条结果记录在结果集合中的行编号
- `ROWID`：用于返回表中每一行的唯一标识符
- `LEVEL`：用于在连接查询中表示连接层次

### 连接池

>  [你真的知道如何设置数据库连接池的大小吗 - rickiyang - 博客园 (cnblogs.com)](https://www.cnblogs.com/rickiyang/p/12239907.html)

*数据库连接池*是程序启动时建立的足够多的数据库连接，这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放

创建数据库连接是一个很耗时的操作，MySQL 短连接每次请求操作数据库都需要与 MySQL 服务器建立 TCP 连接，在并发量非常大的情况会有影响

数据库连接池的机制：
1. 程序初始化时创建连接池
2. 使用时向连接池申请可用连接
3. 使用完毕，将连接返还给连接池
4. 程序退出时，断开连接，并释放资源

- 最大连接数：支持的最大连接数，即能打开连接的最大上限
- 最大空闲连接数： 表示连接池中最多有多少个空闲连接，某个连接做完事务之后暂时空闲，如果连接池中空闲连接数没有达到上限，即可放入连接池，该参数其实可以理解为一共可维护多少个长连接来节约连接建立的成本
- 最长空闲时间： 连接池中连接使用完毕后会等到新的请求到来，表明了连接池中的连接在空闲时能在池子里呆多久，如果长时间没有请求到来，说明请求量非常小，此时就需要释放掉连接来节省资源，等待多久，就是由该参数决定，通常情况下10-20s 就足够了

MYSQL 的最大连接数在5.7版本中默认是151，最大可以达到16384(2^14)
最大连接数太小造成的后果是连接失败，`query failed Error 1040: Too many connections` 错误
太大且当连接该数据库的机器比较多的时候则会对 MYSQL 的性能产生影响，因为系统需要同时维护过多的 TCP 连接

MYSQL 官方给出的设置最大连接数的建议比例为 `Max_used_connections / max_connections * 100% ≈ 85%`

### 临时表

Mysql 内部临时表是分为内存临时表和磁盘临时表，通常在 union 和 group by 会用到临时表，Extra 会显示 Using temporary
如果 group by 需要统计的数据量较大，内存临时表装不下，就会用到磁盘临时表，所以尽量让 group by 过程用上表的索引，这样就不会用到磁盘临时表

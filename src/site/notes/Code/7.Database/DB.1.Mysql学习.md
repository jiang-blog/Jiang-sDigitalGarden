---
{"dg-publish":true,"permalink":"/Code/7.Database/DB.1.Mysql学习/","title":"Mysql 学习","noteIcon":""}
---


# Mysql 学习

MySQL是一个传统的RDBM数据库，也就是关系型数据库，广泛应用于OLTP场景

**OLTP**(联机事务处理)是传统的关系型数据库的主要应用，用于基本的日常交易处理，例如银行的交易记录
**OLAP**(联机分析处理)是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并提供直观和易于理解的查询结果。最常见的应用是复杂的动态报告系统
一般来说，OLTP用于日常处理，OLAP用于数据分析

## 语法

### 数据类型

MySQL 支持所有标准 SQL 数值数据类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型

> [MySQL 数据类型 | 菜鸟教程 (runoob.com)](https://www.runoob.com/mysql/mysql-data-types.html)

#### Varchar & char

Char 是一种固定长度的类型，varchar 则是一种可变长度的类型

Varchar 不是越大越好，在内存加载时每次按最大空间分配，varchar 占用空间大

Varchar 会在行记录头部额外用字节存储长度信息

Varchar(n)中 n 在 V5.0以前代表*最多存储字节数*，之后代表**最多存储字符数**

#### Int

在 int(11)中的11仅代表显示长度为11，不影响存储空间(**将被废弃**)

#### BLOB&TEXT

BLOB 是一个二进制大对象，可以容纳可变数量的数据
有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，区别在于可容纳存储范围不同
TEXT 为非二进制文本数据，同样有4种类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT，与 BLOB 相对应

### SELECT

子句顺序：
| 子句     | 说明               | 是否必须使用           |
| -------- | ------------------ | ---------------------- |
| SELECT   | 要返回的列或表达式 | 是                     |
| FROM     | 从中检索数据的表   | 仅在从表选择数据时使用 |
| WHERE    | 行级过滤           | 否                     |
| GROUP BY | 分组说明           | 仅在按组计算聚集时使用 |
| HAVING   | 组级过滤           | 否                     |
| ORDER BY | 输出排序顺序       | 否                     |
| LIMIT    | 要检索的行数       | 否                     |

### NULL

在匹配过滤和不匹配过滤中都不返回 NULL 值

COUNT(column)对特定列中具有值的行进行计数，忽略 NULL 值

### 大小写

Mysql 中查询数据时是否区分大小写取决于以下几个因素：
- 数据库表的字符集和排序规则
  - 如果字符集是二进制的，如 binary、varbinary 等，那么查询时会区分大小写
  - 如果排序规则是二进制的，如 utf8_bin、latin1_bin 等，那么查询时也会区分大小写
- 数据库表的存储引擎
  - 如果存储引擎是 MyISAM 或 InnoDB，那么查询时会根据字符集和排序规则来判断是否区分大小写
  - 如果存储引擎是 MEMORY 或 CSV，那么查询时不会区分大小写
- 操作系统的文件系统。如果数据库表是以文件形式存储在操作系统中，那么查询时会受到文件系统是否区分大小写的影响
  - 在 Linux 系统中，文件名是区分大小写的，所以查询时也会区分大小写
  - 在 Windows 系统中，文件名是不区分大小写的，所以查询时也不会区分大小写

### 函数

> [MySQL 函数 | 菜鸟教程 (runoob.com)](https://www.runoob.com/mysql/mysql-functions.html)

### 约束

MySQL 唯一约束(Unique Key)要求该列唯一，允许为空，但只能出现一个空值

MySQL 非空约束(NOT NULL)通过 `CREATE TABLE` 或 `ALTER TABLE` 语句中在某个字段的定义后加上关键字 `NOT NULL` 作为限定词，来约束该列的取值不能为空

### 其他

- 应该总是使用4位数字的年份
- 在仅需要日期时始终使用 Date()
- 使用 ORDER BY 排序数据，不依赖 GROUP BY 排序数据
- 如果想从表中删除所有行，不要使用 DELETE，可使用 TRUNCATE TABLE 语句，它完成相同的工作，但速度更快(TRUNCATE 实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据)
- 用 SHOW processlist 可以查看用户正在运行的所有线程以及对应执行的 sql 命令

## 基础知识

### 操作分类

> [SQL |DDL、DQL、DML、DCL 和 TCL 命令 - GeeksforGeeks](https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/)

#### DDL

*数据定义 - Data Definition Language*，用于**创建、修改和删除数据库结构**
- CREATE：用于创建数据库或其对象(如表、索引、函数、视图、存储过程和触发器)
- DROP：用于从数据库中删除对象
- ALTER：用于改变数据库的结构
- TRUNCATE：用于从表中删除所有记录，包括为删除的记录分配的所有空间
- COMMENT：用于向数据字典添加注释
- RENAME：用于重命名数据库中存在的对象

#### DQL

*数据查询 - Data Query Language*，用于**查询架构对象中的数据**
- SELECT：用于从数据库中检索数据

#### DML

*数据操作 - Data Manipulation Language*，为用户提供**添加、删除、更新数据**的能力
- INSERT：用于将数据插入表中
- UPDATE：用于更新表中的现有数据
- DELETE：用于从数据库表中删除记录
- LOCK：表并发控制
- CALL：调用一个 PL/SQL 或 JAVA 子程序
- EXPLAIN PLAN：描述数据的访问路径

#### DCL

*数据控制 - Data Control Language*，主要**处理数据库系统的权限**
- GRANT：此命令授予用户访问数据库的权限
- REVOKE：此命令撤消使用 GRANT 命令授予的用户访问权限

#### TCL

*事务控制 - Transaction Control Language*，主要**控制数据库中的事务**
事务将一组任务分组到单个执行单元中，每个事务都以特定任务开始，并在组中的所有任务成功完成时结束，如果任何任务失败，事务将失败
- BEGIN：开启事务
- COMMIT：提交事务
- ROLLBACK：在发生任何错误的情况下回滚事务
- SAVEPOINT：在事务中设置一个保存点
- SET TRANSACTION： 指定事务的特征

### 三范式

*第一范式*：数据库表的每一字段都是不可分割的基本数据项
在任何一个关系数据库中，1NF 是对关系模式的基本要求，不满足1NF 的数据库就不是关系数据库

*第二范式(依赖性)*：数据库表中的每个实例或行必须可以被唯一的区分
2NF 建立在1NF 之上，要求实体的属性完全依赖于主关键字，不能仅依赖部分主关键字

*第三范式(唯一性)*： 一个数据库表中不包含已在其它表中包含的非主关键字信息
3NF 建立在2NF 之上，非主键字段不能相互依赖，任何非主属性不依赖于其它非主属性

*逆范式*: 通过增加冗余或重复的数据来提高数据库的读性能

### 主键&辅助键&外键

> [主键和外键约束 - SQL Server | Microsoft Learn](https://learn.microsoft.com/zh-cn/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16)

#### 主键

*主键*(PRIMARY KEY)是用于唯一标识数据库中每条记录的字段，不能包含NULL值
选取主键的一个基本原则：**不使用任何业务相关的字段作为主键**

**一个表只能有一个主键约束**，该约束可以包含一个或多个字段，构成主键的多个字段被统一称为*联合主键*

主键设置：
- CREATE创建库时指定
- 通过ALTER添加

主键设计：
- 自增主键设计：数据库会在插入数据时自动为每一条记录分配一个自增整数
  - 用 BIGINT 而非 INT做主键
  - 当达到自增整型类型的上限值时，再次自增插入，MySQL 数据库会报重复错误
  - MySQL 8.0 版本前自增值存在回溯现象，不建议使用
  - 自增值做主键，只能在当前实例中保证唯一，**不能保证全局唯一**
- UUID主键设计：使用一种全局唯一的字符串作为主键
- 业务自定义生成主键：在随机主键基础上结合业务信息生成主键

#### 辅助键

*辅助键*显示每条记录唯一的辅助值，它可用于标识记录，并且通常被索引，它也被称为**备用键**，**一个表可以有多个辅助键**

#### 外键

*外键* (FOREIGN KEY) 是用于在两个表中的数据之间建立和加强链接的一列或多列的组合，约束两个表中数据的**一致性和完整性**
相关联字段中主键所在的表就是主表(父表)，外键所在的表就是从表(子表)，**默认情况下子表的记录相关数据删除后，主表才能删除记录**

## 事务

> [深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kismetv/p/10331633.html)

事务(Transaction)是访问和更新数据库的程序执行单元，事务中可能包含一个或多个sql语句，**这些语句要么都执行，要么都不执行**

```mysql
start transaction; -- begin; -- 事务开始
... # n条sql语句
commit; -- 提交事务，将结果写入数据库
```

如果sql语句执行出现问题，事务调用rollback回滚所有已经执行成功的sql语句

Mysql 中默认采用 *autocommit* 模式，如果没有`start transaction`显式开启一个事务，则**每个sql语句都被当作一个事务执行**
如关闭autocommit，则所有sql语句都在同一事务中，直到执行commit或rollback结束该事务并开启一个新事务

此外存在一些特殊命令，在事务中执行这些命令时会马上强制执行 commit 提交事务，如 DDL 语句(create table/drop table/alter table)和lock tables 语句等等

### ACID

ACID是原子性、一致性、隔离性和持久性的缩写

#### 原子性

**一个事务只有执行成功和失败回滚两种状态，没有中间态**

当事务对数据库进行修改时，InnoDB会生成对应的**undo log**，记录sql执行的相关信息
当发生回滚时InnoDB根据undo log内容做相反工作

#### 持久性

**事务一旦提交，它对数据库的改变就应该是永久性的**

使用 redo log 保证 buffer pool 中的数据不随 Mysql 非正常停止而消失

#### 隔离性

**事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰**

通过锁机制和MVCC保证

#### 一致性

**事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态**

数据库的完整性约束包括实体完整性(如行的主键存在且唯一)、列完整性(如字段的类型、大小、长度要符合要求)、外键约束、用户自定义完整性(如转账前后，两个账户余额的和应该不变)等

### 并发安全

#### 并发问题

Mysql支持多个客户端连接，在同时处理多个事务的时候会出现并发问题，按照严重性从高到低分别为：
- **幻读**：在一个事务内前后查询的符合某条件的记录数量不相同
- **不可重复读**：在一个事务内前后读取的同一个数据不相同
- **脏读**：事务读取了另一个事务修改过但未提交的数据

#### SQL隔离级别

SQL标准针对并发事务执行提出了四种隔离级别，隔离级别越高，开销越大，出现的问题越少，从低到高分别为：
- **读未提交**：指一个事务还没提交时，它做的变更就能被其他事务看到
  - 直接读取最新数据
  - 可能发生脏读、不可重复读和幻读
- **读已提交**：指一个事务提交之后，它做的变更才能被其他事务看到
  - 在每个语句执行前创建 Read View(数据快照)
  - 可能发生不可重复读和幻读
- **可重复读**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的
  - 在事务启动时创建 Read View(数据快照)
  - 可能发生幻读
- **串行化**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行
  - 加读写锁
  - 三种问题都不会发生

> [!Note] Read View
> Read View 中包含四个重要字段：
> ![readview结构.drawio.png (900×437) (xiaolincoding.com)](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png){ #readview}


> [!attention] 事务启动时机
> `begin;/start transaction;`：事务开始未启动，事务启动于下一条增删查改语句
> `start transaction with consistent snapshot;`：事务立刻启动

#### MVCC

MVCC即**多版本并发控制**，通过比较读取行记录的trx_id与Read View确认记录版本，**通过版本链控制并发事务访问**

事务更新行记录后 Mysql 记录相应的 undo log，通过行记录隐藏字段中的 roll_pointer 串联 undo log形成版本链，并将最新记录的 trx_id 设为当前事务 id

- trx_id < min_trx_id: 该版本记录创建/更新于当前事务启动前，可见
- trx_id >= max_trx_id: 该版本记录可能创建/更新于当前事务启动后，不可见
- min_trx_id <= trx_id < max_trx_id
  - trx_id 在m_ids中：该版本记录可能创建/更新于当前事务启动后，不可见
  - trx_id 不在m_ids中：该版本记录创建/更新于当前事务启动前，可见

只有在聚簇索引记录中才有 trx_id 和 roll_pointer,如果某个查询语句使用二级索引来查询，要使用下面的方式判断可见性：
二级索引树索引页的 Page Header 部分存在 `PAGE_MAX_TRX_ID` 属性，记录修改该索引页的最大事务 id
执行增删改操作时，如果执行该操作的事物的事务 id 大于 `PAGE_MAX_TRX_ID`，则将 `PAGE_MAX_TRX_ID` 设置为执行操作的事务 id

当 SELECT 语句访问某个二级索引记录时，如果 readView 的 min_trx_id > PAGE_MAX_TRX_ID，说明该页面中的所有记录对该 ReadView 可见；否则需要执行回表判断
利用二级索引记录中的主键值进行回表操作，得到对应的聚簇索引记录后再按照聚簇索引的方式判断该可见性

#### InnoDB隔离

**InnoDB 引擎的默认隔离级别为可重复读**
MySQL 里除了普通select是**快照读**，其他都是**当前读**，比如 update、insert、delete以及select … for update 等语句

InnoDB通过MVCC解决快照读下的幻读，通过[[Code/7.Database/DB.1.Mysql学习#行级加锁\|行级加锁]]解决当前读情况下的幻读，两种方法很大程度上避免了幻读，但是[**没能完全解决幻读**](https://xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97)
>避免特殊场景下发生幻读的现象的方法就是**尽量在开启事务之后，马上执行 `select … for update` 这类当前读的语句**，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录

## 锁

Mysql根据加锁的范围将锁分为**全局锁**、**表级锁**和**行级锁**

表锁和行锁满足读读共享、读写互斥、写写互斥

### 全局锁

全局加锁
```mysql
flush tables with read lock
```

该sql指令将数据库设为只读状态，**任何其他线程执行的对数据的增删改操作以及对表结构的更改操作都被阻塞**

释放全局锁
```mysql
unlock tables
```

**全局锁主要用于全库逻辑备份**，备份时间过长会造成业务停滞
不使用全局锁，创建事务在**可重复读**隔离级别下通过快照进行备份可避免该问题

### 表级锁

#### 表锁

```mysql
//表级别的共享锁，也就是读锁；
lock tables tablename read;
//表级别的排他锁，也就是写锁；
lock tables tablename write;
```
表锁**同时限制本线程和其他线程对表的读写**
尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能

#### 元数据锁MDL

MDL 锁被 Mysql 隐式使用
- 对一张表进行 CRUD 操作时，加 **MDL 读锁**
- 对一张表做结构变更操作的时候，加 **MDL 写锁**

MDL读锁
- 查询表结构时自动添加
- 执行查询语句时如需扫描表则自动添加
- 执行存储过程时如访问某表则自动添加
MDL写锁
- 修改表结构时自动添加
- 执行写操作时如需扫描表则自动添加
- 执行存储过程时如修改某表则自动添加

MDL锁在事务提交后被释放，且**MDL写锁获取优先级高于读锁**
当长事务MDL读锁堵塞某MDL写锁时,之后的所有MDL读锁都被堵塞

#### 意向锁

- 在使用 InnoDB 引擎的表里对某些记录加上*共享锁*之前，需要先在表级别加上一个*意向共享锁*
- 在使用 InnoDB 引擎的表里对某些记录加上*排他锁*之前，需要先在表级别加上一个*意向排他锁*

意向共享锁和意向排他锁只会和表锁发生冲突
意向锁的目的是快速判断表里是否有记录被加锁

#### AUTO-INC锁

AUTO-INC 锁用于保护表内的自增值，在插入数据时先为表加一个 AUTO-INC 锁再为被 `AUTO_INCREMENT` 修饰的字段赋递增值，以保证表中自增值连续递增

AUTO-INC锁采用特殊表锁机制，在一个SQL语句执行完后立刻释放，而不是在事务结束时释放

V5.1.22后InnoDB提供了一种轻量级新锁代替AUTO-INC锁，在插入数据时为自增字段加锁，赋值后立刻解锁

InnoDB 通过`innodb_autoinc_lock_mode`变量设置使用锁
但可能发生[主从不一致问题](https://xiaolincoding.com/mysql/lock/mysql_lock.html#auto-inc-%E9%94%81)

### 行级锁

InnoDB 引擎支持行级锁而 MyISAM 引擎并不支持

**InnoDB中行锁要等到事务结束时才释放**

#### Record Lock 记录锁

Record Lock分为S锁和X锁，S锁相当于读锁，X锁相当于写锁

#### Gap Lock 间隙锁

Gap Lock只存在于可重复读隔离级别，为范围加锁，范围为开开区间

间隙锁也分为S锁和X锁，但**间隙锁之间都相互兼容**，不存在互斥关系

锁定区间：根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为(A，B)

#### Next-Key Lock 临键锁

临键锁是记录锁和间隙锁的组合，锁定索引本身以及索引之前的间隙，相当于左开右闭区间范围锁

锁定区间(A，B]：
> ![64715c80d9b748d5b9208f244706040a.png (927×315) (alicdn.com)](https://ucc.alicdn.com/pic/developer-ecology/64715c80d9b748d5b9208f244706040a.png)

#### 插入意向锁

插入意向锁是一种**特殊的间隙锁**，但不同于间隙锁的是，该锁只用于并发插入操作

当执行插入操作时，总会检查当前插入位置的下一条行记录(已存在的主索引节点)上是否存在间隙锁对象，判断是否间隙被锁定，如果锁住了，则判定和插入意向锁冲突，当前插入操作被阻塞

**插入意向锁配合间隙锁或临键锁一起防止了幻读操作**

**插入意向锁之间不会互相冲突**，多个插入操作同时插入同一个间隙时无需互相等待

> [!note]
> MySQL 加锁时，先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁

#### 隐式锁

Insert语句正常执行时不生成锁结构，靠聚簇(主键)索引记录自带的 trx_id 隐藏列作为*隐式锁*来保护记录

隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能

隐式锁只有在特殊情况下才会转换为显示锁，例如在并发插入数据的时候发生了主键索引冲突
- 主键索引冲突：先插入记录上的隐式锁变为*X 型记录锁*，后插入新记录的事务尝试给记录添加*S 型记录锁*而阻塞
- 唯一索引冲突：先插入记录上的隐式锁变为*X 型记录锁*，后插入新记录的事务尝试给记录添加*S 型临键锁*而阻塞

### 行级加锁

**行级锁加锁的对象是索引**
锁的基本单位是临键锁，但在**仅使用记录锁或间隙锁就能避免幻读**的情况下，临键锁退化为记录锁或间隙锁

查看加锁情况
```mysql
select * from performance_schema.data_locks\G;
```

没有使用索引的锁定读语句/update 语句/delete 语句会**导致全表扫描**，对每一条记录都加*临键锁*

#### 等值查询

唯一索引：
- 索引上的等值查询，在给唯一索引加锁时，临键锁会退化为*记录锁*，因为主键是唯一的
- 索引上的等值查询， 继续向右遍历时且最后一个值不满足等值条件的时候，临键锁退化为*间隙锁*

非唯一索引：
- 非唯一索引等值查询的过程是一个扫描的过程，**对于二级索引加锁扫描二级索引的 B+树(按照二级索引对记录进行排序)**，扫描到第一条不符合条件的二级索引记录就停止扫描
- 当查询的记录「存在」时，由于不是唯一索引，所以可能存在索引值相同的记录
  - 扫描的过程中对符合条件的二级索引记录加的是*临键锁*
  - 在符合查询条件的记录的主键索引上加*记录锁*
  - 对于第一个不符合条件的二级索引记录，该二级索引的临键锁会退化成*间隙锁*
- 当查询的记录「不存在」时
  - 第一条不符合条件的二级索引记录的临键锁会退化成*间隙锁*
  - 因为不存在满足查询条件的记录，所以不会对主键索引加锁

#### 范围查询

唯一索引：
- 针对`>=`的范围查询，等值查询对应的索引如存在，其上的临键锁退化为*记录锁*
- 针对`<`的范围查询，等值查询对应的索引如存在，其上的临键锁退化为*间隙锁*

非唯一索引范围查询过程中索引的*临键锁*不会退化为*间隙锁*和*记录锁*

### 普通查询

普通的 select 语句不对记录加锁，属于快照读

在查询时加锁的语句称为锁定读
```mysql
-- 对读取的记录加共享锁(S型锁)
select ... lock in share mode;
-- 对读取的记录加排他锁(X型锁)
select ... for update;
```

#### 更新

update 和 delete操作都会加行级排他锁
```mysql
-- 对操作的记录加排他锁(X型锁)
update table .... where id = 1;
-- 对操作的记录加排他锁(X型锁)
delete from table where id = 1;
```

#### 阻塞

插入语句在插入一条记录之前，先定位到该记录在 B+树 的位置，如果插入的位置的下一条记录的索引上有间隙锁，才会发生阻塞

对于update语句的全局加锁，可将 MySQL 里的 `sql_safe_updates` 参数设置为 1，开启安全更新模式
该模式下update必须满足以下条件之一才能执行成功：
- 使用 where，并且 where 条件中必须有索引列
- 使用 limit；
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列
delete 语句必须满足以下条件能执行成功：
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列

### 死锁

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**

可以使用 `select * from performance_schema.data_locks\G` 语句查看 Mysql 加锁情况

Mysql有两种策略通过*打破循环等待条件*来解除死锁状态：
- 设置事务等待锁的超时时间，当一个事务的等待时间超过该值后进行回滚释放锁，InnoDB 中通过参数 `innodb_lock_wait_timeout` 设置超时时间，默认值为50s
- 开启主动死锁检测，主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行，通过参数 `innodb_deadlock_detect`设置，默认为on

## 其他

### 伪列

伪列是指**一些具有特殊含义的列名**，它们并不是表中实际存在的列，但可以在 SQL 查询语句中使用
伪列的行为与表中的列相同，但并未存储具体数值，因此**伪列只具备读属性**

常见的伪列：
- `ROWNUM`：用于返回每条结果记录在结果集合中的行编号
- `ROWID`：用于返回表中每一行的唯一标识符
- `LEVEL`：用于在连接查询中表示连接层次

### 连接池

>  [你真的知道如何设置数据库连接池的大小吗 - rickiyang - 博客园 (cnblogs.com)](https://www.cnblogs.com/rickiyang/p/12239907.html)

*数据库连接池*是程序启动时建立的足够多的数据库连接，这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放

创建数据库连接是一个很耗时的操作，MySQL 短连接每次请求操作数据库都需要与 MySQL 服务器建立 TCP 连接，在并发量非常大的情况会有影响

数据库连接池的机制：
1. 程序初始化时创建连接池
2. 使用时向连接池申请可用连接
3. 使用完毕，将连接返还给连接池
4. 程序退出时，断开连接，并释放资源

- 最大连接数：支持的最大连接数，即能打开连接的最大上限
- 最大空闲连接数： 表示连接池中最多有多少个空闲连接，某个连接做完事务之后暂时空闲，如果连接池中空闲连接数没有达到上限，即可放入连接池，该参数其实可以理解为一共可维护多少个长连接来节约连接建立的成本
- 最长空闲时间： 连接池中连接使用完毕后会等到新的请求到来，表明了连接池中的连接在空闲时能在池子里呆多久，如果长时间没有请求到来，说明请求量非常小，此时就需要释放掉连接来节省资源，等待多久，就是由该参数决定，通常情况下10-20s 就足够了

MYSQL 的最大连接数在5.7版本中默认是151，最大可以达到16384(2^14)
最大连接数太小造成的后果是连接失败，`query failed Error 1040: Too many connections` 错误
太大且当连接该数据库的机器比较多的时候则会对 MYSQL 的性能产生影响，因为系统需要同时维护过多的 TCP 连接

MYSQL 官方给出的设置最大连接数的建议比例为 `Max_used_connections / max_connections * 100% ≈ 85%`

### 临时表

Mysql 内部临时表是分为内存临时表和磁盘临时表，通常在 union 和 group by 会用到临时表，Extra 会显示 Using temporary
如果 group by 需要统计的数据量较大，内存临时表装不下，就会用到磁盘临时表，所以尽量让 group by 过程用上表的索引，这样就不会用到磁盘临时表
